[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Data Science Blog",
    "section": "",
    "text": "Welcome Please choose a blog topic above and begin reading"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "An Introduction to Visualizations in Python",
    "section": "",
    "text": "Data visualization transforms raw numbers into meaningful insights that drive better decision-making. In this comprehensive tutorial, you’ll master the essential skills of creating clear, informative visualizations using pandas and matplotlib.\nWe’ll start by creating a dataset in pandas. Then we’ll explore three fundamental distribution plots: histograms, boxplots, and density plots alongside matplotlib’s universal functions that enhance any plt. Each section builds upon the previous one, progressing from basic plot creation to advanced customization techniques that will make your visualizations both professional and impactful.\nBy the end of this tutorial, you’ll have the knowledge and confidence to transform any dataset into compelling visual stories that clearly communicate your data’s most important patterns and insights.\n(A future blog post will cover downloading a dataset into pandas, and plotting graphs for the relationship between two or more features.)"
  },
  {
    "objectID": "blog.html#obtaining-a-dataset",
    "href": "blog.html#obtaining-a-dataset",
    "title": "Storytelling with Small Data: Beginner-Friendly Visualizations in Python",
    "section": "Obtaining a dataset",
    "text": "Obtaining a dataset\nIn order to visualize data, we first need to obtain some. We will use pandas to create a small dataset.\nFirst, we begin by importing our required libraries, in this case, pandas and matplotlib.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nNow, we will decide how many features we want our dataset to have. These will become our columns.\nFor this example, our dataset with have 4 features: name, gpa, major, and year\nNext we decide how many entries we want in our dataset. For this example, we will do only 10.\nNow, to do this in code, we first create 4 lists of 10 items.\n\nname = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Ethan\", \"Fiona\", \"George\", \"Hannah\", \"Isaac\", \"Julia\"]\n\ngpa = [3.5, 2.8, 3.9, 3.2, 2.5, 3.7, 2.9, 3.8, 3.1, 3.6]  \n\nmajor = [\"Math\", \"Computer Science\", \"Statistics\", \"Math\", \"Computer Science\", \"Statistics\", \"Math\", \"Computer Science\", \"Statistics\", \"Math\"]\n\nyear = [\"Freshman\", \"Sophomore\", \"Junior\", \"Senior\", \"Freshman\", \"Sophomore\", \"Junior\", \"Senior\", \"Freshman\", \"Sophomore\"]\n\nNow that we have created our features, we put them into a pandas dataset.\n\ndata = {\n    \"Name\": name,\n    \"GPA\": gpa,\n    \"Major\": major,\n    \"Year\": year\n}\n\ndf = pd.DataFrame(data)\n\nNow we can begin looking at our data. Before we start graphing, we can look at a small portion of our data, using the .head() function, or the entire set.\n\ndf.head()\n\n\n\n\n\n\n\n\nName\nGPA\nMajor\nYear\n\n\n\n\n0\nAlice\n3.5\nMath\nFreshman\n\n\n1\nBob\n2.8\nComputer Science\nSophomore\n\n\n2\nCharlie\n3.9\nStatistics\nJunior\n\n\n3\nDiana\n3.2\nMath\nSenior\n\n\n4\nEthan\n2.5\nComputer Science\nFreshman\n\n\n\n\n\n\n\n\nprint(df)\n\n      Name  GPA             Major       Year\n0    Alice  3.5              Math   Freshman\n1      Bob  2.8  Computer Science  Sophomore\n2  Charlie  3.9        Statistics     Junior\n3    Diana  3.2              Math     Senior\n4    Ethan  2.5  Computer Science   Freshman\n5    Fiona  3.7        Statistics  Sophomore\n6   George  2.9              Math     Junior\n7   Hannah  3.8  Computer Science     Senior\n8    Isaac  3.1        Statistics   Freshman\n9    Julia  3.6              Math  Sophomore\n\n\nNow we can begin plotting our data using matplotlib."
  },
  {
    "objectID": "blog.html#learning-pandas",
    "href": "blog.html#learning-pandas",
    "title": "An Introduction to Visualizations in Python",
    "section": "Learning Pandas",
    "text": "Learning Pandas\n\nCreating a dataset\nIn order to visualize data effectively, we first need to obtain some. We’ll use pandas to create a small, manageable dataset that will serve as our foundation for learning visualization techniques.\nWe begin by importing our essential libraries. those being pandas for data manipulation and matplotlib for creating visualizations.\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nNow we’ll design our dataset structure by deciding on the number of features (which will become our columns). For this example, our dataset will have 4 features: name, gpa, major, and year. We’ll also determine the size of our dataset, which in this case will be 10. Ten entries will provide enough data to demonstrate various visualization techniques without overwhelming complexity.\nTo create this dataset programmatically, we’ll first construct 4 lists containing 10 items each.\n\nname = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Ethan\", \"Fiona\", \"George\", \"Hannah\", \"Isaac\", \"Julia\"]\n\ngpa = [3.5, 2.8, 3.9, 3.2, 2.5, 1.4, 2.9, 3.8, 2.2, 3.6]  \n\nmajor = [\"Math\", \"Computer Science\", \"Statistics\", \"Math\", \"Computer Science\", \"Statistics\", \"Math\", \"Computer Science\", \"Statistics\", \"Math\"]\n\nyear = [\"Freshman\", \"Sophomore\", \"Junior\", \"Senior\", \"Freshman\", \"Sophomore\", \"Junior\", \"Senior\", \"Freshman\", \"Sophomore\"]\n\nNow that we have our feature data prepared, we’ll combine them into a pandas DataFrame using a dictionary structure. The pd.DataFrame() constructor accepts a dictionary where keys become column names and values become the column data, providing the structured format necessary for effective data analysis and visualization.\n\ndata = {\n    \"name\": name, \n    \"gpa\": gpa, \n    \"major\": major, \n    \"year\": year\n}\n\ndf = pd.DataFrame(data)\n\n\n\nInspecting a dataset\nBefore creating visualizations, it’s crucial to understand your data’s structure and contents. Pandas provides several powerful methods for data exploration and inspection, each serving different analytical needs.\nThe .head() method accepts an optional integer parameter (default value is 5) and displays that number of rows of your dataset. This function provides a quick preview of your data’s structure and content, helping you verify that your data loaded correctly and understand the format of each column.\n(This isn’t particularly helpful when we have created our own dataset by hand, but if you download a dataset, or simply create a much larger one that has more randomness to it, then this is still useful to ensure it is all correctly formatted.)\n\ndf.head()\n\n\n\n\n\n\n\n\nname\ngpa\nmajor\nyear\n\n\n\n\n0\nAlice\n3.5\nMath\nFreshman\n\n\n1\nBob\n2.8\nComputer Science\nSophomore\n\n\n2\nCharlie\n3.9\nStatistics\nJunior\n\n\n3\nDiana\n3.2\nMath\nSenior\n\n\n4\nEthan\n2.5\nComputer Science\nFreshman\n\n\n\n\n\n\n\nTo view the entire dataset, you can use the print() function, which displays all rows and columns. This approach is particularly useful for smaller datasets where you want to see every data point. However, it isn’t really viable for larger datasets, which is why you would use .head().\n\nprint(df)\n\n      name  gpa             major       year\n0    Alice  3.5              Math   Freshman\n1      Bob  2.8  Computer Science  Sophomore\n2  Charlie  3.9        Statistics     Junior\n3    Diana  3.2              Math     Senior\n4    Ethan  2.5  Computer Science   Freshman\n5    Fiona  1.4        Statistics  Sophomore\n6   George  2.9              Math     Junior\n7   Hannah  3.8  Computer Science     Senior\n8    Isaac  2.2        Statistics   Freshman\n9    Julia  3.6              Math  Sophomore\n\n\nFor examining specific features, you can access individual columns by using bracket notation with the column name as a string. This operation returns a pandas Series containing all values from that column, making it easy to focus on particular variables.\n\ndf[\"gpa\"]\n\n0    3.5\n1    2.8\n2    3.9\n3    3.2\n4    2.5\n5    1.4\n6    2.9\n7    3.8\n8    2.2\n9    3.6\nName: gpa, dtype: float64\n\n\nThe .loc function provides another method of obtaining columns by using label-based indexing. It accepts row and column specifications separated by a comma, where the first parameter specifies rows and the second specifies columns.\nUsing : (which you may be familiar with from Python) selects all rows, while providing a list of string column names selects specific columns. This method is particularly good for looking at multiple columns simultaneously.\n\ndf.loc[:, [\"name\", \"gpa\"]]\n\n\n\n\n\n\n\n\nname\ngpa\n\n\n\n\n0\nAlice\n3.5\n\n\n1\nBob\n2.8\n\n\n2\nCharlie\n3.9\n\n\n3\nDiana\n3.2\n\n\n4\nEthan\n2.5\n\n\n5\nFiona\n1.4\n\n\n6\nGeorge\n2.9\n\n\n7\nHannah\n3.8\n\n\n8\nIsaac\n2.2\n\n\n9\nJulia\n3.6\n\n\n\n\n\n\n\nThe .iloc function performs integer-location based selection, allowing you to access rows by their numerical index position. It accepts integer values corresponding to row positions (starting from 0), making it ideal for retrieving specific rows.\n\ndf.iloc[0]\n\nname        Alice\ngpa           3.5\nmajor        Math\nyear     Freshman\nName: 0, dtype: object\n\n\nFor conditional data selection, you can combine boolean indexing with .loc. This approach filters rows based on specific criteria. For example, you can find all rows where a particular column equals a certain value, as demonstrated below.\n\ndf.loc[df[\"name\"] == \"Alice\"]\n\n\n\n\n\n\n\n\nname\ngpa\nmajor\nyear\n\n\n\n\n0\nAlice\n3.5\nMath\nFreshman\n\n\n\n\n\n\n\nThis foundational knowledge of pandas data manipulation and inspection provides the essential tools you need to effectively prepare, explore, and understand your data before creating your visualizations."
  },
  {
    "objectID": "blog.html#visualizing",
    "href": "blog.html#visualizing",
    "title": "Storytelling with Small Data: Beginner-Friendly Visualizations in Python",
    "section": "Visualizing",
    "text": "Visualizing\nIn this tutorial, visualization will be done using matplotlib.\nFirst we will show how you can plot a single feature.\n\nHistogram\nThe first one we will be showing is a histogram, in which we will look at the distribution of gpa.\nThis will be achieved by using plt.hist(), which will create histogram of our data for us. To get it to plot only the gpa’s we will call all the information from the gpa column.\nOne part of using matplotlib, is that you should always use the .show() function after creating a graph. If you don’t you get a bunch of return text that you don’t want to see when you creating your graph. Allow me to show you the difference.\n\nplt.hist(df[\"gpa\"])\n\n(array([1., 0., 0., 1., 1., 1., 1., 1., 2., 2.]),\n array([1.4 , 1.65, 1.9 , 2.15, 2.4 , 2.65, 2.9 , 3.15, 3.4 , 3.65, 3.9 ]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\nNow, you may notice that the graph above, even without the extra text above it, doesn’t look very nice. It ranges from 1.4 to 3.9. This is because we haven’t specified the optional ‘bin’ and ‘range’ parameter. If bin isn’t specified then matplotlib automatically create 10 evenly spaced bins. If range isn’t specified, then it uses the natural min and max of your data.\nHowever, we know that gpas can range from 0.0 to 4.0, thus we can adjust.\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0))\nplt.show()\n\n\n\n\n\n\n\n\nNow, our data is more accurately represented. Since we have the range down, lets see what it looks like with different amounts of bins\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=4)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8)\nplt.show()\n\n\n\n\n\n\n\n\nThese are not the only options for histograms. What if we want to make the bars go horizontal instead of vertical? That can be done by specifying the ‘orientation’ parameter to be horizontal. (By default it is vertical)\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8,orientation='horizontal')\nplt.show()\n\n\n\n\n\n\n\n\nCurrently, the y-axis shows the count for how many values fall into each bin. We can change this to show what percentage of the data falls within each bin by specifying the density parameter.\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, density = True)\nplt.show()\n\n\n\n\n\n\n\n\nAt first glance, this looks like it doesn’t show the probabilities correctly. After all, .2+.2+.6+.2+.8 != 1, in fact, it equals 2. This is because You need to factor in, not only the height of the bins, but the width as well. Since each bin is 0.5 units long, when we multiply each bin’s height by 0.5, and then add them together, we get 1.\nEach bin’s area is what specifies the percentage of data within that bin. We can double check this ourselves. For example, by our math, 40% of our students should have gpas in the range of 3.5-4.0.\n\ndf[\"gpa\"]\n\n0    3.5\n1    2.8\n2    3.9\n3    3.2\n4    2.5\n5    1.4\n6    2.9\n7    3.8\n8    2.2\n9    3.6\nName: gpa, dtype: float64\n\n\nUpon looking, we can confirm that there are four students in this range, with grades of 3.5, 3.6, 3.8, and 3.9.\nNow that the data is shown and organized correctly in the graph, we can make it look exactly how we want.\nThe next parameter we are going to look at is ‘histtype,’ which specifies which type of bars you want for your histogram. There are four options, bar, (which is the default one we’ve been using), step, stepfilled, and barstacked. We will look at each.\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'step')\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'stepfilled')\nplt.show()\n\n\n\n\n\n\n\n\nNow, at first glance it looks like it is no different from the normal ‘bars’ histtype. The difference becomes more noticeable once we color in the edge lines, which by default are not shown.\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', edgecolor='black')\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'stepfilled', edgecolor = 'black')\nplt.show()\n\n\n\n\n\n\n\n\nNow, the barstacked parameter is different, as it stacks bars from multiple datasets on top of each other. Seeing as we are only using one dataset, in order to accurately show the execution of this parameter, we need to create some more data. Since we only care about a single feature, gpa, we will make it a simple pandas series.\n\nmore_data = pd.Series([2.3, 3.8, 1.4, 2.9, 3.5, 1.8, 2.1, 3.0, 1.2, 0.9])\n\nNow we can properly call histtype with barstacked.\n\nplt.hist([df[\"gpa\"],more_data],range=(0.0,4.0),bins=8, histtype = 'barstacked')\nplt.show()\n\n\n\n\n\n\n\n\nNow, what if we don’t want our bars to be touching, what if we want some space? Then we can change the ‘rwidth’ parameter. Naturally it defaults to 1, which makes the bars touch, by reducing that number we can can increase the space in between the bars.\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.9)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.5)\nplt.show()\n\n\n\n\n\n\n\n\nWith these resized bars, they might not look as good being in the middle of their section, this is why we can move them around using the ‘align’ parameter. By default, it is set to ‘mid,’ however, we can specify to align left or right.\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.5, align = 'left')\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.5, align = 'right')\nplt.show()\n\n\n\n\n\n\n\n\nNow that we have our data where we want it to be, we can choose what color to portray it in. Sometimes blue isn’t always the right choice. We can specify this color by using the ‘color’ parameter.\n\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.9, color = \"green\")\nplt.show()\n\n\n\n\n\n\n\n\nWhat if we have a scenario with multiple datasets, and want to specify colors for each? Then we simply puts the colors in a list that is in the same order as the list of datasets we pass in.\n\nplt.hist([df[\"gpa\"],more_data],range=(0.0,4.0),bins=8, histtype = 'barstacked', color=[\"purple\", \"pink\"])\nplt.show()\n\n\n\n\n\n\n\n\nHowever, it is not very obvious which dataset belongs to which bars. To clarify this, we can use the label parameter. We can do this similarly to how we did colors, by inputting a list that corresponds to the inputted datasets.\nThis parameter is a bit more complicated than all of our other parameters though, as it requires more than just manipulating the hist function itself. In addition, we have to call the legend function from matplotlib itself. This is followed by the show function, to ensure the legend appears on our graph with our labels.\n\nplt.hist([df[\"gpa\"],more_data],range=(0.0,4.0),bins=8, histtype = 'barstacked', color=[\"purple\", \"pink\"], label=[\"Morning Class\",\"Evening Class\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nWe could even make our graph more intricate by using matplotlib’s label function to specify the label for the x-axis and the y-axis.\n\nplt.hist([df[\"gpa\"],more_data],range=(0.0,4.0),bins=8, histtype = 'barstacked', color=[\"purple\", \"pink\"], label=[\"Morning Class\",\"Evening Class\"])\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Count\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThis wraps up the most important details to know about histograms. Next we will move on to boxplots\n\n\nBoxplot\nFirst of all, to create a boxplot, we simply use .boxplot(). Just like with bar graphs, we can choose to show data from one set of data, or from multiple.\n\nplt.boxplot(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot([df[\"gpa\"],more_data])\nplt.show()\n\n\n\n\n\n\n\n\nNow, these boxplots show a lot of information, but what they don’t show is where the mean is relatively in all this data. We can change this by using the ‘showmeans’ parameter. By setting it to true\n\nplt.boxplot(df[\"gpa\"],showmeans=True)\nplt.show()\n\n\n\n\n\n\n\n\nBut what if we want this mean to shown as a line instead of a point? We can manipulate that as well by using the ‘meanline’ parameter, and setting it to True.\n\nplt.boxplot(df[\"gpa\"],showmeans=True, meanline=True)\nplt.show()\n\n\n\n\n\n\n\n\nOnce, again, like with the histograms, we can change whether we want to view these vertically or horizontally.\n\nplt.boxplot(df[\"gpa\"],vert=False)\nplt.show()\n\n\n\n\n\n\n\n\nNow we can really begin manipulating how our graph looks by using the ‘boxprops’, ‘whiskerprops’, ‘capprops’, ‘flierprops’, ‘mediansprops’, ‘meanprops’, and ‘patch_artist’ parameters. Something to note about all these parameters is that they are dictionaries that have multiple parameters within. For most of these those parameters are ‘color’, ‘linewidth’, and ‘linestyle,’ but I will show the specifics as we move along.\nFirst, boxprops. This parameter controls the features relating to the main rectangle than encases Q1 through Q3. It contains ‘linewidth’ and ‘linestyle’ from earlier, alongside ‘edgecolor’ and ‘facecolor’. These control the color of the lines around the rectangle and the color of the rectangle respectively. However, facecolor will only work if a second parameter, ‘patch_artist,’ is set to true. When patch_artist is false, then the boxplots are empty of any color, if it is true, then you can decide what color to fill it with.\n(Also, it’s important to note that if you decide you only want to color the lines and not fill in the plot, then you would simply call the parameter ‘color’ instead of ‘edgecolor,’ since now there is nothing to differentiate.)\nThese color parameters can be changed the exact same way as the color parameter was changed with the histograms. ‘linewidth’ is 1 by default, and we can set it to any float to make it thinner or thicker.\nFinally, ‘linestyle’ gives you several options to choose from for the design of your line. * ‘-’ → solid * ‘–’ → dashed * ‘-.’ → dash-dot * ‘:’ → dotted * None’ or ’’ → no line\nNow, we can put it all together.\n\nplt.boxplot(df[\"gpa\"],patch_artist=True, boxprops=dict(facecolor=\"lightblue\", edgecolor=\"blue\", linewidth=2, linestyle=\"--\")) \nplt.show()\n\n\n\n\n\n\n\n\nNow, let’s say that I want to show you the difference between all the different line styles in the same graph by combining multiple graphs together. How would this be done?\nIn order to show all the possible line styles succinctly, we will learn another, more complicated matplotlib function: subplots(). This function allows us to put multiple separate plots into a single picture.\nFor this example we will use the boxplot graph we created earlier using boxprops, but change it slightly to show multiple plots of different line styles.\nFirst, .subplots requires the amount of total plots you want in your picture. You tell it this by inputting the number of rows and the number of columns which equal your total number of graphs. For this example we will do 2 rows with 3 columns, for a total of 6 graphs. (There are only five different line styles. I could theoretically do 1 row and 5 columns, or vis versa, but this illustrates the subplots functions far better. Thus, I will simply do the ‘None’ option twice.)\n\nfig, axes = plt.subplots(2, 3)\n\n\n\n\n\n\n\n\nThis returns a figure for us to fill in and the axes (plural of axis) of the total picture.\nWe can then begin filling them in with our boxplots by specifying where in the overall picture they go. We do this by specifying the two axes correlating to their position.\nWe can also add a title to each boxplot by specifying a title for that axis.\n\naxes[0, 0].boxplot(df[\"gpa\"],patch_artist=True, boxprops=dict(facecolor=\"lightblue\", edgecolor=\"blue\", linewidth=2, linestyle=\"-\")) \naxes[0, 0].set_title(\"Solid Line\")\naxes[0, 1].boxplot(df[\"gpa\"],patch_artist=True, boxprops=dict(facecolor=\"lightblue\", edgecolor=\"blue\", linewidth=2, linestyle=\"--\")) \naxes[0, 1].set_title(\"Dashed Line\")\naxes[0, 2].boxplot(df[\"gpa\"],patch_artist=True, boxprops=dict(facecolor=\"lightblue\", edgecolor=\"blue\", linewidth=2, linestyle=\"\")) \naxes[0, 2].set_title(\"No Line\")\naxes[1, 0].boxplot(df[\"gpa\"],patch_artist=True, boxprops=dict(facecolor=\"lightblue\", edgecolor=\"blue\", linewidth=2, linestyle=\":\")) \naxes[1, 0].set_title(\"Dotted Line\")\naxes[1, 1].boxplot(df[\"gpa\"],patch_artist=True, boxprops=dict(facecolor=\"lightblue\", edgecolor=\"blue\", linewidth=2, linestyle=\"-.\")) \naxes[1, 1].set_title(\"Dash-Dot Line\")\naxes[1, 2].boxplot(df[\"gpa\"],patch_artist=True, boxprops=dict(facecolor=\"lightblue\", edgecolor=\"blue\", linewidth=2, linestyle=\"None\")) \naxes[1, 2].set_title(\"No Line\")\nplt.show()\n\nWe will also use the tight_layout() function to ensure that our plots don’t accidentally overlap with each other. plt.tight_layout()\n\nplt.boxplot(df[\"gpa\"],vert=False, whiskerprops = dict(color=\"green\", linestyle=\":\", linewidth=2))\nplt.show()\n\n\n\n\n\n\n\n\nNow that we have seen all the options for changing the visuals of a single boxplot, lets apply it to multiple. This time, its not as simple, as putting the color options in a list. We actually have to create separate boxplots and then plot them all onto one graph. For this to work nicely, we are going to require one more parameter. This is the ‘position’ parameter, and changes where the boxplot sits on the x-axis."
  },
  {
    "objectID": "blog.html#visualizing-1",
    "href": "blog.html#visualizing-1",
    "title": "Storytelling with Small Data: Beginner-Friendly Visualizations in Python",
    "section": "Visualizing",
    "text": "Visualizing\nIn this tutorial, visualization will be done using matplotlib.\nFirst we will show how you can plot a single feature.\n\nHistogram\nThe first one we will be showing is a histogram, in which we will look at the distribution of gpa.\nThis will be achieved by using plt.hist(), which will create histogram of our data for us. To get it to plot only the gpa’s we will call all the information from the gpa column.\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"])\nHowever, you may notice that this graph doesn’t look very nice. It ranges from 1.4 to 3.9. This is because we haven’t specified the optional ‘bin’ and ‘range’ parameter. If bin isn’t specified then matplotlib automatically create 10 evenly spaced bins. If range isn’t specified, then it uses the natural min and max of your data.\nHowever, we know that gpas can range from 0.0 to 4.0, thus we can adjust. quarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0))\nNow, our data is more accurately represented. Since we have the range down, lets see what it looks like with different amounts of bins\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=4)\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8)\nThese are not the only options for histograms. What if we want to make the bars go horizontal instead of vertical? That can be done by specifying the ‘orientation’ parameter to be horizontal. (By default it is vertical)\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8,orientation='horizontal')\nCurrently, the y-axis shows the count for how many values fall into each bin. We can change this to show what percentage of the data falls within each bin by specifying the density parameter. quarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, density = True)\nAt first glance, this looks like it doesn’t show the probabilities correctly. After all, .2+.2+.6+.2+.8 != 1, in fact, it equals 2. This is because You need to factor in, not only the height of the bins, but the width as well. Since each bin is 0.5 units long, when we multiply each bin’s height by 0.5, and then add them together, we get 1.\nEach bin’s area is what specifies the percentage of data within that bin. We can double check this ourselves. For example, by our math, 40% of our students should have gpas in the range of 3.5-4.0. quarto-executable-code-5450563D\ndf[\"gpa\"]\nUpon looking, we can confirm that there are four students in this range, with grades of 3.5, 3.6, 3.8, and 3.9.\nNow that the data is shown and organized correctly in the graph, we can make it look exactly how we want.\nThe next parameter we are going to look at is ‘histtype,’ which specifies which type of bars you want for your histogram. There are four options, bar, (which is the default one we’ve been using), step, stepfilled, and barstacked. We will look at each. quarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'step')\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'stepfilled')\nNow, at first glance it looks like it is no different from the normal ‘bars’ histtype. The difference becomes more noticeable once we color in the edge lines, which by default are not shown.\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', edgecolor='black')\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'stepfilled', edgecolor = 'black')\nNow, the barstacked parameter is different, as it stacks bars from multiple datasets on top of each other. Seeing as we are only using one dataset, in order to accurately show the execution of this parameter, we need to create some more data. Since we only care about a single feature, gpa, we will make it a simple pandas series.\nquarto-executable-code-5450563D\nmore_data = pd.Series([2.3, 3.8, 1.4, 2.9, 3.5, 1.8, 2.1, 3.0, 1.2, 0.9])\nNow we can properly call histtype with barstacked. quarto-executable-code-5450563D\nplt.hist([df[\"gpa\"],more_data],range=(0.0,4.0),bins=8, histtype = 'barstacked')\nNow, what if we don’t want our bars to be touching, what if we want some space? Then we can change the ‘rwidth’ parameter. Naturally it defaults to 1, which makes the bars touch, by reducing that number we can can increase the space in between the bars.\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.9)\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.5)\nWith these resized bars, they might not look as good being in the middle of their section, this is why we can move them around using the ‘align’ parameter. By default, it is set to ‘mid,’ however, we can specify to align left or right.\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.5, align = 'left')\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.5, align = 'right')\nNow that we have our data where we want it to be, we can choose what color to portray it in. Sometimes blue isn’t always the right choice. We can specify this color by using the ‘color’ parameter.\nquarto-executable-code-5450563D\nplt.hist(df[\"gpa\"],range=(0.0,4.0),bins=8, histtype = 'bar', rwidth = 0.9, color = \"green\")\nWhat if we have a scenario with ``````````````````` :::"
  },
  {
    "objectID": "blog.html#creating-a-dataset",
    "href": "blog.html#creating-a-dataset",
    "title": "An Introduction to Visualizations in Python",
    "section": "Creating a dataset",
    "text": "Creating a dataset\nIn order to visualize data, we first need to obtain some. We will use pandas to create a small dataset.\nFirst, we begin by importing our required libraries, in this case, pandas and matplotlib.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nNow, we will decide how many features we want our dataset to have. These will become our columns.\nFor this example, our dataset with have 4 features: name, gpa, major, and year\nNext we decide how many entries we want in our dataset. For this example, we will do only 10.\nNow, to do this in code, we first create 4 lists of 10 items.\n\nname = [\"Alice\",  \"Bob\",  \"Charlie\",  \"Diana\",  \"Ethan\",  \"Fiona\",  \"George\",  \"Hannah\",  \"Isaac\",  \"Julia\"]\n\ngpa = [3.5,  2.8,  3.9,  3.2,  2.5,  1.4,  2.9,  3.8,  2.2,  3.6]  \n\nmajor = [\"Math\",  \"Computer Science\",  \"Statistics\",  \"Math\",  \"Computer Science\",  \"Statistics\",  \"Math\",  \"Computer Science\",  \"Statistics\",  \"Math\"]\n\nyear = [\"Freshman\",  \"Sophomore\",  \"Junior\",  \"Senior\",  \"Freshman\",  \"Sophomore\",  \"Junior\",  \"Senior\",  \"Freshman\",  \"Sophomore\"]\n\nNow that we have created our features, we put them into a pandas dataset.\n\ndata = {\n    \"name\": name, \n    \"gpa\": gpa, \n    \"major\": major, \n    \"year\": year\n}\n\ndf = pd.DataFrame(data)"
  },
  {
    "objectID": "blog.html#inspecting-a-dataset",
    "href": "blog.html#inspecting-a-dataset",
    "title": "An Introduction to Visualizations in Python",
    "section": "Inspecting a dataset",
    "text": "Inspecting a dataset\nNow we can begin looking at our data. Before we start graphing, we can look at a small portion of our data, using the .head() function, or the entire set.\n\ndf.head()\n\n\n\n\n\n\n\n\nname\ngpa\nmajor\nyear\n\n\n\n\n0\nAlice\n3.5\nMath\nFreshman\n\n\n1\nBob\n2.8\nComputer Science\nSophomore\n\n\n2\nCharlie\n3.9\nStatistics\nJunior\n\n\n3\nDiana\n3.2\nMath\nSenior\n\n\n4\nEthan\n2.5\nComputer Science\nFreshman\n\n\n\n\n\n\n\n\nprint(df)\n\n      name  gpa             major       year\n0    Alice  3.5              Math   Freshman\n1      Bob  2.8  Computer Science  Sophomore\n2  Charlie  3.9        Statistics     Junior\n3    Diana  3.2              Math     Senior\n4    Ethan  2.5  Computer Science   Freshman\n5    Fiona  1.4        Statistics  Sophomore\n6   George  2.9              Math     Junior\n7   Hannah  3.8  Computer Science     Senior\n8    Isaac  2.2        Statistics   Freshman\n9    Julia  3.6              Math  Sophomore\n\n\nAdditionally, we can look only at specific columns or features of our graph by simply indexing by column name.\n\ndf[\"gpa\"]\n\n0    3.5\n1    2.8\n2    3.9\n3    3.2\n4    2.5\n5    1.4\n6    2.9\n7    3.8\n8    2.2\n9    3.6\nName: gpa, dtype: float64\n\n\nThis works well for one column, but what if we want to access more?\nWe can also look at multiple columns at the same time by using the loc function. This function finds rows or columns by their label.\nWithin the brackets you have the row followed by a comma, followed by the column. If you are familiar with Python slicing, then you know that : is used to obtain an entire section, in our case, a row or a column.\nThis allows us to look at multiple columns at once.\n\ndf.loc[:,  [\"name\",  \"gpa\"]]\n\n\n\n\n\n\n\n\nname\ngpa\n\n\n\n\n0\nAlice\n3.5\n\n\n1\nBob\n2.8\n\n\n2\nCharlie\n3.9\n\n\n3\nDiana\n3.2\n\n\n4\nEthan\n2.5\n\n\n5\nFiona\n1.4\n\n\n6\nGeorge\n2.9\n\n\n7\nHannah\n3.8\n\n\n8\nIsaac\n2.2\n\n\n9\nJulia\n3.6\n\n\n\n\n\n\n\nWe can also look at individual rows in a dataframe. We do this by using the iloc function. This function stands for integer location. It is used by inputting the index of the row you would like to use.\n\ndf.iloc[0]\n\nname        Alice\ngpa           3.5\nmajor        Math\nyear     Freshman\nName: 0, dtype: object\n\n\nFinally we can access a row by checking if it fulfills a certain condition, such as one of the columns holding a specific value, and then using .loc.\n\ndf.loc[df[\"name\"] == \"Alice\"]\n\n\n\n\n\n\n\n\nname\ngpa\nmajor\nyear\n\n\n\n\n0\nAlice\n3.5\nMath\nFreshman\n\n\n\n\n\n\n\nThis actually returns a pandas Series instead of pandas DataFrame, but the specifics of Pandas are not important for this tutorial, so we will ignore this.\nWith this basic pandas knowledge at our disposal, we can now begin learning how to visualize our data."
  },
  {
    "objectID": "blog.html#relationship-graphs-2d-graphs",
    "href": "blog.html#relationship-graphs-2d-graphs",
    "title": "Storytelling with Small Data: Beginner-Friendly Visualizations in Python",
    "section": "Relationship Graphs (2D Graphs)",
    "text": "Relationship Graphs (2D Graphs)\n\nScatterplot\n\n\nLineplot\n\n\nBarplot"
  },
  {
    "objectID": "blog.html#d-graphs",
    "href": "blog.html#d-graphs",
    "title": "Storytelling with Small Data: Beginner-Friendly Visualizations in Python",
    "section": "3D Graphs",
    "text": "3D Graphs\nFor this section, we will only be covering one type of plot\n\nScatterplot"
  },
  {
    "objectID": "blog.html#distribution-graphs-1d-graphs",
    "href": "blog.html#distribution-graphs-1d-graphs",
    "title": "Storytelling with Small Data: Beginner-Friendly Visualizations in Python",
    "section": "Distribution Graphs (1D Graphs)",
    "text": "Distribution Graphs (1D Graphs)\nFirst we will show how you can plot a single feature with various distribution graphs.\n\nHistogram\nThe first one we will be showing is a histogram, in which we will look at the distribution of gpa.\nThis will be achieved by using plt.hist(), which will create histogram of our data for us. To get it to plot only the gpa’s we will call all the information from the gpa column.\nOne part of using matplotlib, is that you should always use the .show() function after creating a graph. If you don’t you get a bunch of return text that you don’t want to see when you creating your graph. Allow me to show you the difference.\n\nplt.hist(df[\"gpa\"])\n\n(array([1., 0., 0., 1., 1., 1., 1., 1., 2., 2.]),\n array([1.4 , 1.65, 1.9 , 2.15, 2.4 , 2.65, 2.9 , 3.15, 3.4 , 3.65, 3.9 ]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\nNow, you may notice that the graph above, even without the extra text above it, doesn’t look very nice. It ranges from 1.4 to 3.9. This is because we haven’t specified the optional bin and range parameter. If bin isn’t specified then matplotlib automatically create 10 evenly spaced bins. If range isn’t specified, then it uses the natural min and max of your data.\nHowever, we know that gpas can range from 0.0 to 4.0, thus we can adjust.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0))\nplt.show()\n\n\n\n\n\n\n\n\nNow, our data is more accurately represented. Since we have the range down, lets see what it looks like with different amounts of bins\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 4)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.show()\n\n\n\n\n\n\n\n\nThese are not the only options for histograms. What if we want to make the bars go horizontal instead of vertical? That can be done by specifying the orientation parameter to be horizontal. (By default it is vertical)\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, orientation = \"horizontal\")\nplt.show()\n\n\n\n\n\n\n\n\nCurrently, the y-axis shows the count for how many values fall into each bin. We can change this to show what percentage of the data falls within each bin by specifying the density parameter.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  density = True)\nplt.show()\n\n\n\n\n\n\n\n\nAt first glance, this looks like it doesn’t show the probabilities correctly. After all, .2+.2+.6+.2+.8 ! =  1, in fact, it equals 2. This is because You need to factor in, not only the height of the bins, but the width as well. Since each bin is 0.5 units long, when we multiply each bin’s height by 0.5, and then add them together, we get 1.\nEach bin’s area is what specifies the percentage of data within that bin. We can double check this ourselves. For example, by our math, 40% of our students should have gpas in the range of 3.5-4.0.\n\ndf[\"gpa\"]\n\n0    3.5\n1    2.8\n2    3.9\n3    3.2\n4    2.5\n5    1.4\n6    2.9\n7    3.8\n8    2.2\n9    3.6\nName: gpa, dtype: float64\n\n\nUpon looking, we can confirm that there are four students in this range, with grades of 3.5, 3.6, 3.8, and 3.9.\nNow that the data is shown and organized correctly in the graph, we can make it look exactly how we want.\nThe next parameter we are going to look at is histtype, which specifies which type of bars you want for your histogram. There are four options, bar, (which is the default one we`ve been using), step, stepfilled, and barstacked. We will look at each.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"step\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"stepfilled\")\nplt.show()\n\n\n\n\n\n\n\n\nNow, at first glance it looks like it is no different from the normal bars histtype. The difference becomes more noticeable once we color in the edge lines, which by default are not shown.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"stepfilled\",  edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\nNow, the barstacked parameter is different, as it stacks bars from multiple datasets on top of each other. Seeing as we are only using one dataset, in order to accurately show the execution of this parameter, we need to create some more data. Since we only care about a single feature, gpa, we will make it a simple pandas series.\n\nmore_data = pd.Series([2.3,  3.8,  1.4,  2.9,  3.5,  1.8,  2.1,  3.0,  1.2,  0.9])\n\nNow we can properly call histtype with barstacked.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  histtype = \"barstacked\")\nplt.show()\n\n\n\n\n\n\n\n\nNow, what if we don’t want our bars to be touching, what if we want some space? Then we can change the rwidth parameter. Naturally it defaults to 1, which makes the bars touch, by reducing that number we can can increase the space in between the bars.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.9)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.5)\nplt.show()\n\n\n\n\n\n\n\n\nWith these resized bars, they might not look as good being in the middle of their section, this is why we can move them around using the align parameter. By default, it is set to mid, however, we can specify to align left or right.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.5,  align = \"left\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.5,  align = \"right\")\nplt.show()\n\n\n\n\n\n\n\n\nNow that we have our data where we want it to be, we can choose what color to portray it in. Sometimes blue isn’t always the right choice. We can specify this color by using the color parameter.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.9,  color = \"green\")\nplt.show()\n\n\n\n\n\n\n\n\nWhat if we have a scenario with multiple datasets, and want to specify colors for each? Then we simply puts the colors in a list that is in the same order as the list of datasets we pass in.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  histtype = \"barstacked\",  color = [\"purple\",  \"pink\"])\nplt.show()\n\n\n\n\n\n\n\n\nHowever, it is not very obvious which dataset belongs to which bars. To clarify this, we can use the label parameter. We can do this similarly to how we did colors, by inputting a list that corresponds to the inputted datasets.\nThis parameter is a bit more complicated than all of our other parameters though, as it requires more than just manipulating the hist function itself. In addition, we have to call the legend function from matplotlib itself. This is followed by the show function, to ensure the legend appears on our graph with our labels.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  histtype = \"barstacked\",  color = [\"purple\",  \"pink\"],  label = [\"Morning Class\", \"Evening Class\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThis wraps up the most important details to know about histograms. Next we will move on to some of matplotlib’s universal functions.\n\n\nUniversal Matplotlib Functions\nBefore we continue to the next graph, there are some functions not directly tied to any graph that we should know. These are matplotlib functions that are universal to all graphs.\nFirst there are the plot labels, these are specific to certain axes. In our case, .xlabel() and .ylabel(). You simply fill these in with a string of your choice. They should the unit of measurement for each of your axes.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Count\")\nplt.show()\n\n\n\n\n\n\n\n\nAdditionally, we can set a title for the graph overall by using the .title() function and inputting a string for our title.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.title(\"Grades\")\nplt.show()\n\n\n\n\n\n\n\n\nIf we want to we could also add grid lines by setting plt.grid() to True. (This isn’t the most useful for a small histogram like this, but I`m sure you could see how this would be useful on something like a scatter plot)\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFinally, we can add in a bit of text to our graph using plt.text(). We can use this to explain context or any other information needed to understand our graph.\nInstead of simply taking in a string, boolean, or simply being called empty, we need to specify where our text is going in the graph. The parameters for this function are .text(x-coordinate,  y-coordinate,  string of text).\nThis can be done in two ways. First, with a fixed position by setting the x and y coordinate manually, like so.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(.1,  4,  \"These are the best and worst classes\")\nplt.show()\n\n\n\n\n\n\n\n\nHowever, this isn’t the most convenient way, and could result in lots of trial and error before finding the right location, especially if you want it somewhere simple. For example, lets say that you want it in the top right corner of the graph.\nThen, instead of specifying x and y as direct values, we can specify them as coordinates relative to their axis. For example, 1 would be the max, and 0 would be the minimum. However, for this to work, we must tell matplotlib that we are changing x and y from units to relative units. This is done with the transform parameter, specifically by making it equal plt.gca().transAxes.\nTo translate that code to english. gca stands for “get current axes,” and .transAxes tells it to transform into relative axis units.\nPutting this together allows us to do this.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(1.0,  1.0,  \"This is the best class\",  transform = plt.gca().transAxes\n)\nplt.show()\n\n\n\n\n\n\n\n\nHowever, you may notice that it isn’t staying in the corner, it is actually going outside the graph. to keep our text inside our graph we need to specify a few more variables. This being, va and ha. (va is vertical alignment, while ha is horizontal alignment.)\nThese parameters are specified simply with a string corresponding to the location of where we want our text. The options for these are, va: bottom, center, top, ha: left, center, and right\n(va actually also has baseline and center_baseline, but those aren’t as useful, so you don’t need to worry about remembering them as much.)\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(1.0,  1.0,  \"This is the best class\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nHowever, even this doesn’t look quite right. It is too squished. We can fix this by offsetting a little bit from being exactly in the corner.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(0.95,  0.95,  \"This is the best class\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nPutting everything we have learned together we can get a graph that looks like this.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  rwidth = 0.9,  histtype = \"barstacked\",  color = [\"purple\",  \"pink\"],  label = [\"Morning Class\", \"Evening Class\"])\nplt.legend()\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Count\")\nplt.title(\"Grades\")\nplt.text(0.95,  0.95,  \"These are the best and worst classes\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nThis isn’t necessarily the nicest looking graph, but it does show you what all our options put together look like, and when you make your graphs, you can pick and choose for what matters most to telling the story of your data.\nNow, there is one final universal function left to cover, which is plt.subplots(). This function allows you to put multiple smaller graphs into one large picture.\nFirst, .subplots() requires the amount of total plots you want in your picture. You tell it this by inputting the number of rows and the number of columns which equal your total number of graphs. For this example we will do 2 rows with 3 columns, for a total of 6 graphs.\n\nfig,  axes = plt.subplots(2,  3)\n\n\n\n\n\n\n\n\nThis returns a figure for us to fill in and the axes of the total picture.\nFor this example, we will take our bar graph, and simply show off different colors, but just know you can have various and different graphs for each slot. (For example, you could have 3 bar graphs, 2 whisker plots and a scatterplot all put together.)\nWe can then begin filling them in with our graphs by specifying where in the overall picture they go. We do this by specifying the two axes correlating to their position.\n(Please note that you must do plt.subplots() and name the axes in the same section of code as filling out the axes for it to work.)\n\nfig,  axes = plt.subplots(2,  3)\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"lightblue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\n\nplt.show()\n\n\n\n\n\n\n\n\nNow that the graphs are plotted, we should make sure that people actually understand what they are looking at. We can do this by adding a title to each boxplot by specifying a title for that axis. Additionally, we can add an overall title that covers all our graphs by using the plt.suptitle().\nWe will also use the .tight_layout() function to ensure that our plots don’t accidentally overlap with each other, and generally make our graphs look neater next to each other.\n\nfig,  axes = plt.subplots(2,  3)\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFinally, we can add one more parameter to .subplots(). This parameter is called figsize, and controls how large the overall graphs appears. Here is are a few examples of our previous subplot graph in various sizes, ((12, 8), (10, 6), (8, 4)). You may need to experiment to find a size that perfectly fits your graphs.\n\nfig,  axes = plt.subplots(2,  3,  figsize = (12, 8))\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig,  axes = plt.subplots(2,  3,  figsize = (10, 6))\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig,  axes = plt.subplots(2,  3,  figsize = (8, 4))\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis covers the most important universal functions in matplotlib. Next, we will move on to boxplots.\n\n\nBoxplot\nFirst of all, to create a boxplot, we simply use .boxplot(). Just like with bar graphs, we can choose to show data from one set of data, or from multiple.\n\nplt.boxplot(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot([df[\"gpa\"], more_data])\nplt.show()\n\n\n\n\n\n\n\n\nOnce we have multiple sets of data, we can also add a label to differentiate them, just like with our histograms.\n\nplt.boxplot([df[\"gpa\"], more_data], labels = [\"Class A\",  \"Class B\"])\nplt.legend()\nplt.show()\n\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_31240\\2780255427.py:1: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  plt.boxplot([df[\"gpa\"], more_data], labels = [\"Class A\",  \"Class B\"])\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_31240\\2780255427.py:2: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n\n\n\n\n\n\n\n\n\nNow, these boxplots show a lot of information, but what they don’t show is where the mean is relatively in all this data. We can change this by using the showmeans parameter. By setting it to true\n\nplt.boxplot(df[\"gpa\"], showmeans = True)\nplt.show()\n\n\n\n\n\n\n\n\nBut what if we want this mean to shown as a line instead of a point? We can manipulate that as well by using the meanline parameter, and setting it to True.\n\nplt.boxplot(df[\"gpa\"], showmeans = True,  meanline = True)\nplt.show()\n\n\n\n\n\n\n\n\nOnce, again, like with the histograms, we can change whether we want to view these vertically or horizontally.\n\nplt.boxplot(df[\"gpa\"], vert = False)\nplt.show()\n\n\n\n\n\n\n\n\nNow we can really begin manipulating how our graph looks by using the boxprops, whiskerprops, capprops, flierprops, mediansprops, meanprops, and patch_artist parameters. Something to note about all these parameters is that they are dictionaries that have multiple parameters within. For most of these those parameters are color, linewidth, and linestyle, but I will show the specifics as we move along.\nFirst, boxprops. This parameter controls the features relating to the main rectangle than encases Q1 through Q3. It contains linewidth and linestyle from earlier, alongside edgecolor and facecolor. These control the color of the lines around the rectangle and the color of the rectangle respectively.\nHowever, facecolor and linestyle are mutually exclusive parameters. This is because facecolor will only work if a second parameter, patch_artist, is set to true. When patch_artist is false, then the boxplots are empty of any color, and you can specify linestyle as you desire.\n(Also, it’s important to note that if you decide you only want to color the lines and choose not fill in the plot, then you would simply call the parameter color instead of edgecolor, since now there is nothing to differentiate.)\nThese color parameters can be changed the exact same way as the color parameter was changed with the histograms. linewidth is 1 by default, and we can set it to any float to make it thinner or thicker.\nTo break up all this text, here is a graph showing you the code to create a boxplot that is filled in with some blue color.\n\nplt.boxplot(df[\"gpa\"], patch_artist = True,  boxprops = dict(facecolor = \"lightblue\",  edgecolor = \"blue\",  linewidth = 2)) \nplt.show()\n\n\n\n\n\n\n\n\nFinally, linestyle gives you several options to choose from for the design of your line.\n\n“-” → solid\n“–” → dashed\n“-.” → dash-dot\n“:” → dotted\n“None” or “” → no line\n\nHere is an example of every kind of line style. Since there are 5 styles, I will show them with a subplot of 1 row and 5 lines.\n(patch_artist is False by default, so we can simply delete rather than manually setting it to False.)\n\nfig,  axes = plt.subplots(1,  5)\n\naxes[0].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"-\")) \naxes[0].set_title(\"Solid Line\")\naxes[1].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"--\")) \naxes[1].set_title(\"Dashed Line\")\naxes[2].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"-.\")) \naxes[2].set_title(\"Dash-Dot Line\")\naxes[3].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \":\")) \naxes[3].set_title(\"Dotted Line\")\naxes[4].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"\")) \naxes[4].set_title(\"No Line\")\n\nplt.suptitle(\"Line Styles\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNext, we will move on to the whiskerprops parameters for the whisker properties. This parameter has the usual subparameters of color, linestyle, and linewidth, each of which have already been previously explained\n\nplt.boxplot(df[\"gpa\"],  whiskerprops = dict(color = \"green\",  linestyle = \":\",  linewidth = 1))\nplt.show()\n\n\n\n\n\n\n\n\nNext, we will move on to capprops. This parameter controls the caps on the end of each whisker. Once again, it has the usual subparameters of color, linestyle, and linewidth.\n\nplt.boxplot(df[\"gpa\"],  capprops = dict(color = \"orange\",  linestyle = \"-\",  linewidth = 3))\nplt.show()\n\n\n\n\n\n\n\n\nNext on the list is flierprops. This controls what the outliers on your graph look like. Unlike the other parameters, this one has the unique subparameters of marker, markerfacecolor, markeredgecolor, and markersize.\nFirstly, marker specifies the shape of the marker. The options for this are:\n\no circle\ns square\nD diamond\n^ triangle up\nv triangle down\n&lt; triangle left\n&gt; triangle right\nx X\n+ plus\n* star\np pentagon\nh hexagon\n. point (very small)\n\nmarkerfacecolor and markeredgecolor are the fill color and edge color of the marker respectively. They are simply specified by a string as with previous color parameters.\nFinally markersize is an int corresponding to the size you wish the outlier to be.\nPutting it all together creates a graph like this.\n\nplt.boxplot(df[\"gpa\"],  flierprops = dict(marker = \"*\",  markerfacecolor = \"pink\",  markeredgecolor = \"red\",  markersize = 3))\nplt.show()\n\n\n\n\n\n\n\n\nNext is medianprops. This parameter controls the look of the median line in the graph. It has the usual subparameters of color, linestyle, and linewidth.\n\nplt.boxplot(df[\"gpa\"],  medianprops = dict(color = \"lightgreen\",  linestyle = \"-.\",  linewidth = .75))\nplt.show()\n\n\n\n\n\n\n\n\nFinally we end with the parameter meanprops. This controls the look of the mean marker/line, (if it was added). It is similar to flierprops and has the same parameters of marker, markerfacecolor, markeredgecolor, and markersize. These are used exactly as before.\nI will demonstrate how it looks with both a marker and a line.\n\nplt.boxplot(df[\"gpa\"],  showmeans = True,  meanprops = dict(marker = \"D\",  markerfacecolor = \"yellow\",  markeredgecolor = \"cyan\",  markersize = 6))\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot(df[\"gpa\"],  showmeans = True,  meanline = True,  meanprops = dict(marker = \"X\",  markerfacecolor = \"magenta\",  markeredgecolor = \"skyblue\",  markersize = 10))\nplt.show()\n\n\n\n\n\n\n\n\nAs you can see, when you turn the mean into a line, when you specify meanprops, it applies these properties to two markers that it creates on either end of the line.\nFinally, lets try applying these to two datasets in one boxplot. If you try modifying both boxplots in one line, you will find that it doesn’t work. This is a time where we need to actually create two separate boxplots and then put them on the same graph. We will make sure they don’t land on top of each other by using the actual final parameter for this section, position.\nYou can specify the position of a certain plot with an integer, so long as no position is the same for two graphs, they will line up neatly and not on top of each other.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"lightblue\",  edgecolor = \"blue\",  linewidth = .5),  medianprops = dict(color = \"orange\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"lightblue\",  markeredgecolor = \"blue\",  markersize = 6),  capprops = dict(color = \"yellow\",  linestyle = \"--\",  linewidth = 5), positions = [1])\n\nplt.boxplot(more_data, showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"pink\",  edgecolor = \"red\",  linewidth = .5),  medianprops = dict(color = \"green\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"pink\",  markeredgecolor = \"red\",  markersize = 6),  capprops = dict(color = \"lightgreen\",  linestyle = \"--\",  linewidth = 5), positions = [2])\n\nplt.show()\n\n\n\n\n\n\n\n\nNow that we have seen all the options for changing the visuals of a single boxplot, lets add it all together in one boxplot and see what it looks like.\n(We will also be including some of our universal matplotlib functions.)\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"lightblue\",  edgecolor = \"blue\",  linewidth = .5),  medianprops = dict(color = \"orange\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"lightblue\",  markeredgecolor = \"blue\",  markersize = 6),  capprops = dict(color = \"yellow\",  linestyle = \"--\",  linewidth = 5), positions = [1])\n\nplt.boxplot(more_data, showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"pink\",  edgecolor = \"red\",  linewidth = .5),  medianprops = dict(color = \"green\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"pink\",  markeredgecolor = \"red\",  markersize = 6),  capprops = dict(color = \"lightgreen\",  linestyle = \"--\",  linewidth = 5), positions = [2])\n\nplt.legend()\nplt.xlabel(\"The Class\")\nplt.ylabel(\"GPA\")\nplt.title(\"Grades for each Class\")\nplt.text(0.95,  0.95,  \"These are the best and worst classes\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.grid(True)\nplt.show()\n\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_31240\\3257490930.py:5: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n\n\n\n\n\n\n\n\n\nThis covers the all the basics that you should need for creating boxplots. Next, we work with density graphs.\n\n\nDensity"
  },
  {
    "objectID": "blog2.html",
    "href": "blog2.html",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "Post in progress…\nPlease check again later for a completed post, the following is merely an outline.\n\n\nHello again. In my previous visualization post we discussed how to plot graphs when you are looking at exactly 1 feature, this time we will continue our learning by moving on to 2 features and further!\n\n\n\n\n\nBefore we begin, we need to download a dataset to work with. To do so, we will be using …\n\n\n\nNow we will find out exactly what data we are working with. By this, I mean that we will check exactly how the information is stored within our DataFrame.\n\n\n\n\nIn a previous post we’ve looked at visualizations that focus on one variable at a time. These are great for showing distributions, but often in data science, what we care about is the relationship between at least two variables.\nIn this section, we’ll cover how to use matplotlib to show relationships between pairs of features in our dataset.\nThe first type of plot we’ll cover is the scatter plot.\n\n\n\n\n\n\n\n\n\n\n\n\nFor this section, we will only cover how to use the scatterplot we are familiar with to move from a 2D into a 3D setting."
  },
  {
    "objectID": "blog2.html#downloading-a-dataset",
    "href": "blog2.html#downloading-a-dataset",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "Downloading a dataset",
    "text": "Downloading a dataset\nBefore we begin, we need to download a dataset to work with. To do so, we will be using …"
  },
  {
    "objectID": "blog2.html#inspecting-the-dataset",
    "href": "blog2.html#inspecting-the-dataset",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "Inspecting the dataset",
    "text": "Inspecting the dataset\nNow we will find out exactly what data we are working with. By this, I mean that we will check exactly how the information is stored within our DataFrame."
  },
  {
    "objectID": "blog2.html#scatterplot",
    "href": "blog2.html#scatterplot",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "Scatterplot",
    "text": "Scatterplot"
  },
  {
    "objectID": "blog2.html#lineplot",
    "href": "blog2.html#lineplot",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "Lineplot",
    "text": "Lineplot"
  },
  {
    "objectID": "blog2.html#barplot",
    "href": "blog2.html#barplot",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "Barplot",
    "text": "Barplot"
  },
  {
    "objectID": "blog2.html#scatterplot-1",
    "href": "blog2.html#scatterplot-1",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "Scatterplot",
    "text": "Scatterplot"
  },
  {
    "objectID": "blog.html#histogram",
    "href": "blog.html#histogram",
    "title": "An Introduction to Visualizations in Python",
    "section": "Histogram",
    "text": "Histogram\nThe first one we will be showing is a histogram, in which we will look at the distribution of gpa.\nThis will be achieved by using plt.hist(), which will create histogram of our data for us. To get it to plot only the gpa’s we will call all the information from the gpa column.\nOne part of using matplotlib, is that you should always use the .show() function after creating a graph. If you don’t you get a bunch of return text that you don’t want to see when you creating your graph. Allow me to show you the difference.\n\nplt.hist(df[\"gpa\"])\n\n(array([1., 0., 0., 1., 1., 1., 1., 1., 2., 2.]),\n array([1.4 , 1.65, 1.9 , 2.15, 2.4 , 2.65, 2.9 , 3.15, 3.4 , 3.65, 3.9 ]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\nNow, you may notice that the graph above, even without the extra text above it, doesn’t look very nice. It ranges from 1.4 to 3.9. This is because we haven’t specified the optional bin and range parameter. If bin isn’t specified then matplotlib automatically create 10 evenly spaced bins. If range isn’t specified, then it uses the natural min and max of your data.\nHowever, we know that gpas can range from 0.0 to 4.0, thus we can adjust.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0))\nplt.show()\n\n\n\n\n\n\n\n\nNow, our data is more accurately represented. Since we have the range down, lets see what it looks like with different amounts of bins\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 4)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.show()\n\n\n\n\n\n\n\n\nThese are not the only options for histograms. What if we want to make the bars go horizontal instead of vertical? That can be done by specifying the orientation parameter to be horizontal. (By default it is vertical)\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, orientation = \"horizontal\")\nplt.show()\n\n\n\n\n\n\n\n\nCurrently, the y-axis shows the count for how many values fall into each bin. We can change this to show what percentage of the data falls within each bin by specifying the density parameter.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  density = True)\nplt.show()\n\n\n\n\n\n\n\n\nAt first glance, this looks like it doesn’t show the probabilities correctly. After all, .2+.2+.6+.2+.8 ! =  1, in fact, it equals 2. This is because You need to factor in, not only the height of the bins, but the width as well. Since each bin is 0.5 units long, when we multiply each bin’s height by 0.5, and then add them together, we get 1.\nEach bin’s area is what specifies the percentage of data within that bin. We can double check this ourselves. For example, by our math, 40% of our students should have gpas in the range of 3.5-4.0.\n\ndf[\"gpa\"]\n\n0    3.5\n1    2.8\n2    3.9\n3    3.2\n4    2.5\n5    1.4\n6    2.9\n7    3.8\n8    2.2\n9    3.6\nName: gpa, dtype: float64\n\n\nUpon looking, we can confirm that there are four students in this range, with grades of 3.5, 3.6, 3.8, and 3.9.\nNow that the data is shown and organized correctly in the graph, we can make it look exactly how we want.\nThe next parameter we are going to look at is histtype, which specifies which type of bars you want for your histogram. There are four options, bar, (which is the default one we`ve been using), step, stepfilled, and barstacked. We will look at each.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"step\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"stepfilled\")\nplt.show()\n\n\n\n\n\n\n\n\nNow, at first glance it looks like it is no different from the normal bars histtype. The difference becomes more noticeable once we color in the edge lines, which by default are not shown.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"stepfilled\",  edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\nNow, the barstacked parameter is different, as it stacks bars from multiple datasets on top of each other. Seeing as we are only using one dataset, in order to accurately show the execution of this parameter, we need to create some more data. Since we only care about a single feature, gpa, we will make it a simple pandas series.\n\nmore_data = pd.Series([2.3,  3.8,  1.4,  2.9,  3.5,  1.8,  2.1,  3.0,  1.2,  0.9])\n\nNow we can properly call histtype with barstacked.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  histtype = \"barstacked\")\nplt.show()\n\n\n\n\n\n\n\n\nNow, what if we don’t want our bars to be touching, what if we want some space? Then we can change the rwidth parameter. Naturally it defaults to 1, which makes the bars touch, by reducing that number we can can increase the space in between the bars.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.9)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.5)\nplt.show()\n\n\n\n\n\n\n\n\nWith these resized bars, they might not look as good being in the middle of their section, this is why we can move them around using the align parameter. By default, it is set to mid, however, we can specify to align left or right.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.5,  align = \"left\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.5,  align = \"right\")\nplt.show()\n\n\n\n\n\n\n\n\nNow that we have our data where we want it to be, we can choose what color to portray it in. Sometimes blue isn’t always the right choice. We can specify this color by using the color parameter.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8,  histtype = \"bar\",  rwidth = 0.9,  color = \"green\")\nplt.show()\n\n\n\n\n\n\n\n\nWhat if we have a scenario with multiple datasets, and want to specify colors for each? Then we simply puts the colors in a list that is in the same order as the list of datasets we pass in.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  histtype = \"barstacked\",  color = [\"purple\",  \"pink\"])\nplt.show()\n\n\n\n\n\n\n\n\nHowever, it is not very obvious which dataset belongs to which bars. To clarify this, we can use the label parameter. We can do this similarly to how we did colors, by inputting a list that corresponds to the inputted datasets.\nThis parameter is a bit more complicated than all of our other parameters though, as it requires more than just manipulating the hist function itself. In addition, we have to call the legend function from matplotlib itself. This is followed by the show function, to ensure the legend appears on our graph with our labels.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  histtype = \"barstacked\",  color = [\"purple\",  \"pink\"],  label = [\"Morning Class\", \"Evening Class\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThis wraps up the most important details to know about histograms. Next we will move on to some of matplotlib’s universal functions."
  },
  {
    "objectID": "blog.html#universal-matplotlib-functions",
    "href": "blog.html#universal-matplotlib-functions",
    "title": "An Introduction to Visualizations in Python",
    "section": "Universal Matplotlib Functions",
    "text": "Universal Matplotlib Functions\nBefore we continue to the next graph, there are some functions not directly tied to any graph that we should know. These are matplotlib functions that are universal to all graphs.\nFirst there are the plot labels, these are specific to certain axes. In our case, .xlabel() and .ylabel(). You simply fill these in with a string of your choice. They should the unit of measurement for each of your axes.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Count\")\nplt.show()\n\n\n\n\n\n\n\n\nAdditionally, we can set a title for the graph overall by using the .title() function and inputting a string for our title.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.title(\"Grades\")\nplt.show()\n\n\n\n\n\n\n\n\nIf we want to we could also add grid lines by setting plt.grid() to True. (This isn’t the most useful for a small histogram like this, but I`m sure you could see how this would be useful on something like a scatter plot)\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFinally, we can add in a bit of text to our graph using plt.text(). We can use this to explain context or any other information needed to understand our graph.\nInstead of simply taking in a string, boolean, or simply being called empty, we need to specify where our text is going in the graph. The parameters for this function are .text(x-coordinate,  y-coordinate,  string of text).\nThis can be done in two ways. First, with a fixed position by setting the x and y coordinate manually, like so.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(.1,  4,  \"These are the best and worst classes\")\nplt.show()\n\n\n\n\n\n\n\n\nHowever, this isn’t the most convenient way, and could result in lots of trial and error before finding the right location, especially if you want it somewhere simple. For example, lets say that you want it in the top right corner of the graph.\nThen, instead of specifying x and y as direct values, we can specify them as coordinates relative to their axis. For example, 1 would be the max, and 0 would be the minimum. However, for this to work, we must tell matplotlib that we are changing x and y from units to relative units. This is done with the transform parameter, specifically by making it equal plt.gca().transAxes.\nTo translate that code to english. gca stands for “get current axes,” and .transAxes tells it to transform into relative axis units.\nPutting this together allows us to do this.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(1.0,  1.0,  \"This is the best class\",  transform = plt.gca().transAxes\n)\nplt.show()\n\n\n\n\n\n\n\n\nHowever, you may notice that it isn’t staying in the corner, it is actually going outside the graph. to keep our text inside our graph we need to specify a few more variables. This being, va and ha. (va is vertical alignment, while ha is horizontal alignment.)\nThese parameters are specified simply with a string corresponding to the location of where we want our text. The options for these are, va: bottom, center, top, ha: left, center, and right\n(va actually also has baseline and center_baseline, but those aren’t as useful, so you don’t need to worry about remembering them as much.)\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(1.0,  1.0,  \"This is the best class\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nHowever, even this doesn’t look quite right. It is too squished. We can fix this by offsetting a little bit from being exactly in the corner.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(0.95,  0.95,  \"This is the best class\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nPutting everything we have learned together we can get a graph that looks like this.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8,  rwidth = 0.9,  histtype = \"barstacked\",  color = [\"purple\",  \"pink\"],  label = [\"Morning Class\", \"Evening Class\"])\nplt.legend()\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Count\")\nplt.title(\"Grades\")\nplt.text(0.95,  0.95,  \"These are the best and worst classes\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nThis isn’t necessarily the nicest looking graph, but it does show you what all our options put together look like, and when you make your graphs, you can pick and choose for what matters most to telling the story of your data.\nNow, there is one final universal function left to cover, which is plt.subplots(). This function allows you to put multiple smaller graphs into one large picture.\nFirst, .subplots() requires the amount of total plots you want in your picture. You tell it this by inputting the number of rows and the number of columns which equal your total number of graphs. For this example we will do 2 rows with 3 columns, for a total of 6 graphs.\n\nfig,  axes = plt.subplots(2,  3)\n\n\n\n\n\n\n\n\nThis returns a figure for us to fill in and the axes of the total picture.\nFor this example, we will take our bar graph, and simply show off different colors, but just know you can have various and different graphs for each slot. (For example, you could have 3 bar graphs, 2 whisker plots and a scatterplot all put together.)\nWe can then begin filling them in with our graphs by specifying where in the overall picture they go. We do this by specifying the two axes correlating to their position.\n(Please note that you must do plt.subplots() and name the axes in the same section of code as filling out the axes for it to work.)\n\nfig,  axes = plt.subplots(2,  3)\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"lightblue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\n\nplt.show()\n\n\n\n\n\n\n\n\nNow that the graphs are plotted, we should make sure that people actually understand what they are looking at. We can do this by adding a title to each boxplot by specifying a title for that axis. Additionally, we can add an overall title that covers all our graphs by using the plt.suptitle().\nWe will also use the .tight_layout() function to ensure that our plots don’t accidentally overlap with each other, and generally make our graphs look neater next to each other.\n\nfig,  axes = plt.subplots(2,  3)\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFinally, we can add one more parameter to .subplots(). This parameter is called figsize, and controls how large the overall graphs appears. Here is are a few examples of our previous subplot graph in various sizes, ((12, 8), (10, 6), (8, 4)). You may need to experiment to find a size that perfectly fits your graphs.\n\nfig,  axes = plt.subplots(2,  3,  figsize = (12, 8))\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig,  axes = plt.subplots(2,  3,  figsize = (10, 6))\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig,  axes = plt.subplots(2,  3,  figsize = (8, 4))\n\naxes[0,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0,  0].set_title(\"Class Blue\")\naxes[0,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0,  1].set_title(\"Class Yellow\")\naxes[0,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0,  2].set_title(\"Class Teal\")\naxes[1,  0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1,  0].set_title(\"Class Magenta\")\naxes[1,  1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1,  1].set_title(\"Class Cyan\")\naxes[1,  2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1,  2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis covers the most important universal functions in matplotlib. Next, we will move on to boxplots."
  },
  {
    "objectID": "blog.html#boxplot",
    "href": "blog.html#boxplot",
    "title": "An Introduction to Visualizations in Python",
    "section": "Boxplot",
    "text": "Boxplot\nFirst of all, to create a boxplot, we simply use .boxplot(). Just like with bar graphs, we can choose to show data from one set of data, or from multiple.\n\nplt.boxplot(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot([df[\"gpa\"], more_data])\nplt.show()\n\n\n\n\n\n\n\n\nOnce we have multiple sets of data, we can also add a label to differentiate them, just like with our histograms.\n\nplt.boxplot([df[\"gpa\"], more_data], labels = [\"Class A\",  \"Class B\"])\nplt.legend()\nplt.show()\n\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_28932\\2780255427.py:1: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  plt.boxplot([df[\"gpa\"], more_data], labels = [\"Class A\",  \"Class B\"])\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_28932\\2780255427.py:2: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n\n\n\n\n\n\n\n\n\nNow, these boxplots show a lot of information, but what they don’t show is where the mean is relatively in all this data. We can change this by using the showmeans parameter. By setting it to true\n\nplt.boxplot(df[\"gpa\"], showmeans = True)\nplt.show()\n\n\n\n\n\n\n\n\nBut what if we want this mean to shown as a line instead of a point? We can manipulate that as well by using the meanline parameter, and setting it to True.\n\nplt.boxplot(df[\"gpa\"], showmeans = True,  meanline = True)\nplt.show()\n\n\n\n\n\n\n\n\nOnce, again, like with the histograms, we can change whether we want to view these vertically or horizontally.\n\nplt.boxplot(df[\"gpa\"], vert = False)\nplt.show()\n\n\n\n\n\n\n\n\nNow we can really begin manipulating how our graph looks by using the boxprops, whiskerprops, capprops, flierprops, mediansprops, meanprops, and patch_artist parameters. Something to note about all these parameters is that they are dictionaries that have multiple parameters within. For most of these those parameters are color, linewidth, and linestyle, but I will show the specifics as we move along.\nFirst, boxprops. This parameter controls the features relating to the main rectangle than encases Q1 through Q3. It contains linewidth and linestyle from earlier, alongside edgecolor and facecolor. These control the color of the lines around the rectangle and the color of the rectangle respectively.\nHowever, facecolor and linestyle are mutually exclusive parameters. This is because facecolor will only work if a second parameter, patch_artist, is set to true. When patch_artist is false, then the boxplots are empty of any color, and you can specify linestyle as you desire.\n(Also, it’s important to note that if you decide you only want to color the lines and choose not fill in the plot, then you would simply call the parameter color instead of edgecolor, since now there is nothing to differentiate.)\nThese color parameters can be changed the exact same way as the color parameter was changed with the histograms. linewidth is 1 by default, and we can set it to any float to make it thinner or thicker.\nTo break up all this text, here is a graph showing you the code to create a boxplot that is filled in with some blue color.\n\nplt.boxplot(df[\"gpa\"], patch_artist = True,  boxprops = dict(facecolor = \"lightblue\",  edgecolor = \"blue\",  linewidth = 2)) \nplt.show()\n\n\n\n\n\n\n\n\nFinally, linestyle gives you several options to choose from for the design of your line.\n\n“-” → solid\n“–” → dashed\n“-.” → dash-dot\n“:” → dotted\n“None” or “” → no line\n\nHere is an example of every kind of line style. Since there are 5 styles, I will show them with a subplot of 1 row and 5 lines.\n(patch_artist is False by default, so we can simply delete rather than manually setting it to False.)\n\nfig,  axes = plt.subplots(1,  5)\n\naxes[0].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"-\")) \naxes[0].set_title(\"Solid Line\")\naxes[1].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"--\")) \naxes[1].set_title(\"Dashed Line\")\naxes[2].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"-.\")) \naxes[2].set_title(\"Dash-Dot Line\")\naxes[3].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \":\")) \naxes[3].set_title(\"Dotted Line\")\naxes[4].boxplot(df[\"gpa\"],  boxprops = dict(color = \"red\",  linewidth = 4,  linestyle = \"\")) \naxes[4].set_title(\"No Line\")\n\nplt.suptitle(\"Line Styles\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNext, we will move on to the whiskerprops parameters for the whisker properties. This parameter has the usual subparameters of color, linestyle, and linewidth, each of which have already been previously explained\n\nplt.boxplot(df[\"gpa\"],  whiskerprops = dict(color = \"green\",  linestyle = \":\",  linewidth = 1))\nplt.show()\n\n\n\n\n\n\n\n\nNext, we will move on to capprops. This parameter controls the caps on the end of each whisker. Once again, it has the usual subparameters of color, linestyle, and linewidth.\n\nplt.boxplot(df[\"gpa\"],  capprops = dict(color = \"orange\",  linestyle = \"-\",  linewidth = 3))\nplt.show()\n\n\n\n\n\n\n\n\nNext on the list is flierprops. This controls what the outliers on your graph look like. Unlike the other parameters, this one has the unique subparameters of marker, markerfacecolor, markeredgecolor, and markersize.\nFirstly, marker specifies the shape of the marker. The options for this are:\n\no circle\ns square\nD diamond\n^ triangle up\nv triangle down\n&lt; triangle left\n&gt; triangle right\nx X\n+ plus\n* star\np pentagon\nh hexagon\n. point (very small)\n\nmarkerfacecolor and markeredgecolor are the fill color and edge color of the marker respectively. They are simply specified by a string as with previous color parameters.\nFinally markersize is an int corresponding to the size you wish the outlier to be.\nPutting it all together creates a graph like this.\n\nplt.boxplot(df[\"gpa\"],  flierprops = dict(marker = \"*\",  markerfacecolor = \"pink\",  markeredgecolor = \"red\",  markersize = 3))\nplt.show()\n\n\n\n\n\n\n\n\nNext is medianprops. This parameter controls the look of the median line in the graph. It has the usual subparameters of color, linestyle, and linewidth.\n\nplt.boxplot(df[\"gpa\"],  medianprops = dict(color = \"lightgreen\",  linestyle = \"-.\",  linewidth = .75))\nplt.show()\n\n\n\n\n\n\n\n\nFinally we end with the parameter meanprops. This controls the look of the mean marker/line, (if it was added). It is similar to flierprops and has the same parameters of marker, markerfacecolor, markeredgecolor, and markersize. These are used exactly as before.\nI will demonstrate how it looks with both a marker and a line.\n\nplt.boxplot(df[\"gpa\"],  showmeans = True,  meanprops = dict(marker = \"D\",  markerfacecolor = \"yellow\",  markeredgecolor = \"cyan\",  markersize = 6))\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot(df[\"gpa\"],  showmeans = True,  meanline = True,  meanprops = dict(marker = \"X\",  markerfacecolor = \"magenta\",  markeredgecolor = \"skyblue\",  markersize = 10))\nplt.show()\n\n\n\n\n\n\n\n\nAs you can see, when you turn the mean into a line, when you specify meanprops, it applies these properties to two markers that it creates on either end of the line.\nFinally, lets try applying these to two datasets in one boxplot. If you try modifying both boxplots in one line, you will find that it doesn’t work. This is a time where we need to actually create two separate boxplots and then put them on the same graph. We will make sure they don’t land on top of each other by using the actual final parameter for this section, position.\nYou can specify the position of a certain plot with an integer, so long as no position is the same for two graphs, they will line up neatly and not on top of each other.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"lightblue\",  edgecolor = \"blue\",  linewidth = .5),  medianprops = dict(color = \"orange\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"lightblue\",  markeredgecolor = \"blue\",  markersize = 6),  capprops = dict(color = \"yellow\",  linestyle = \"--\",  linewidth = 5), positions = [1])\n\nplt.boxplot(more_data, showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"pink\",  edgecolor = \"red\",  linewidth = .5),  medianprops = dict(color = \"green\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"pink\",  markeredgecolor = \"red\",  markersize = 6),  capprops = dict(color = \"lightgreen\",  linestyle = \"--\",  linewidth = 5), positions = [2])\n\nplt.show()\n\n\n\n\n\n\n\n\nNow that we have seen all the options for changing the visuals of a single boxplot, lets add it all together in one boxplot and see what it looks like.\n(We will also be including some of our universal matplotlib functions.)\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"lightblue\",  edgecolor = \"blue\",  linewidth = .5),  medianprops = dict(color = \"orange\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"lightblue\",  markeredgecolor = \"blue\",  markersize = 6),  capprops = dict(color = \"yellow\",  linestyle = \"--\",  linewidth = 5), positions = [1])\n\nplt.boxplot(more_data, showmeans = True, meanline = False,  meanprops = dict(marker = \"D\",  markerfacecolor = \"cyan\",  markeredgecolor = \"blue\",  markersize = 8),  patch_artist = True,  boxprops = dict(facecolor = \"pink\",  edgecolor = \"red\",  linewidth = .5),  medianprops = dict(color = \"green\",  linestyle = \"-\",  linewidth = 2), flierprops = dict(marker = \"s\",  markerfacecolor = \"pink\",  markeredgecolor = \"red\",  markersize = 6),  capprops = dict(color = \"lightgreen\",  linestyle = \"--\",  linewidth = 5), positions = [2])\n\nplt.legend()\nplt.xlabel(\"The Class\")\nplt.ylabel(\"GPA\")\nplt.title(\"Grades for each Class\")\nplt.text(0.95,  0.95,  \"These are the best and worst classes\",  ha = \"right\",  va = \"top\",  transform = plt.gca().transAxes)\nplt.grid(True)\nplt.show()\n\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_28932\\3257490930.py:5: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n\n\n\n\n\n\n\n\n\nThis covers the all the basics that you should need for creating boxplots. Next, we work with density graphs."
  },
  {
    "objectID": "blog.html#density",
    "href": "blog.html#density",
    "title": "An Introduction to Visualizations in Python",
    "section": "Density",
    "text": "Density"
  },
  {
    "objectID": "blog.html#introduction",
    "href": "blog.html#introduction",
    "title": "An Introduction to Visualizations in Python",
    "section": "",
    "text": "Data visualization transforms raw numbers into meaningful insights that drive better decision-making. In this comprehensive tutorial, you’ll master the essential skills of creating clear, informative visualizations using pandas and matplotlib.\nWe’ll start by creating a dataset in pandas. Then we’ll explore three fundamental distribution plots: histograms, boxplots, and density plots alongside matplotlib’s universal functions that enhance any plt. Each section builds upon the previous one, progressing from basic plot creation to advanced customization techniques that will make your visualizations both professional and impactful.\nBy the end of this tutorial, you’ll have the knowledge and confidence to transform any dataset into compelling visual stories that clearly communicate your data’s most important patterns and insights.\n(A future blog post will cover downloading a dataset into pandas, and plotting graphs for the relationship between two or more features.)"
  },
  {
    "objectID": "blog.html#distribution-graphs-1-feature",
    "href": "blog.html#distribution-graphs-1-feature",
    "title": "An Introduction to Visualizations in Python",
    "section": "Distribution Graphs (1 Feature)",
    "text": "Distribution Graphs (1 Feature)\nFirst we will show how you can plot a single feature with various distribution graphs.\n\nHistogram\nThe first visualization we’ll explore is a histogram, which displays the frequency distribution of our data by dividing it into bins. For this example, we’ll examine the distribution of GPA values from our dataset.\nWe create histograms using plt.hist(), which automatically counts how many data points fall into each range and displays them as bars. To plot only the GPA values, we’ll extract all the information from the gpa column.\nAn essential aspect of using matplotlib is that you should always use the .show() function after creating a graph. Without it, you’ll see unwanted return text that clutters your visualization. Allow me demonstrate the difference.\n\nplt.hist(df[\"gpa\"])\n\n(array([1., 0., 0., 1., 1., 1., 1., 1., 2., 2.]),\n array([1.4 , 1.65, 1.9 , 2.15, 2.4 , 2.65, 2.9 , 3.15, 3.4 , 3.65, 3.9 ]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\nYou may notice that even the clean version above doesn’t look optimal, the x-axis ranges from 1.4 to 3.9. This happens because we haven’t specified the optional bins and range parameters.\nThe bins parameter accepts an integer and determines how many equal-width intervals your data is divided into. If not specified, matplotlib automatically creates 10 evenly spaced bins. The range parameter accepts a tuple of two float values (min, max) and sets the boundaries for your histogram. If not specified, it uses the natural minimum and maximum of your data.\nHowever, since we know that GPAs typically range from 0.0 to 4.0, we can adjust our visualization accordingly.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0))\nplt.show()\n\n\n\n\n\n\n\n\nNow that our data is more accurately represented within the proper GPA scale, let’s explore how different numbers of bins affect the visualization.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 4)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.show()\n\n\n\n\n\n\n\n\nThese aren’t the only customization options for histograms. The orientation parameter accepts string values and controls whether bars are displayed vertically or horizontally, with the graph defaulting to vertical.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, orientation = \"horizontal\")\nplt.show()\n\n\n\n\n\n\n\n\nCurrently, the y-axis shows the count of values falling into each bin. We can change this to display the probability density by setting the density parameter, which accepts a boolean value. When set to True, the histogram shows the relative frequency rather than absolute counts.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, density = True)\nplt.show()\n\n\n\n\n\n\n\n\nAt first glance, this might seem incorrect since the heights don’t appear to sum to 1. This is because you need to consider both the height and width of each bin. Since each bin is 0.5 units wide, multiplying each bin’s height by 0.5 and summing them gives us 1. Each bin’s area represents the percentage of data within that range.\nThe histtype parameter accepts string values and specifies the visual style of your histogram bars. There are four options: \"bar\" (default solid bars), \"step\" (unfilled outlines), \"stepfilled\" (filled step plots), and \"barstacked\" (for multiple datasets). Allow me to show you each.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"step\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"stepfilled\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\")\nplt.show()\n\n\n\n\n\n\n\n\nAt first \"bar\" and \"stepfilled\" might appear exactly the same. However, the difference becomes more apparent when we add edge lines using the edgecolor parameter, which accepts any valid matplotlib color string.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"stepfilled\", edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\nThe \"barstacked\" option is designed for comparing multiple datasets by stacking their bars. To demonstrate this properly, we need additional data. Since we’re focusing on a single feature, we’ll create a simple pandas Series.\n\nmore_data = pd.Series([2.3, 3.8, 1.4, 2.9, 3.5, 1.8, 2.1, 3.0, 1.2, 0.9])\n\nNow we can properly demonstrate the barstacked histogram.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8, histtype = \"barstacked\")\nplt.show()\n\n\n\n\n\n\n\n\nThe rwidth parameter accepts a float value between 0 and 1 and controls the relative width of the bars. The default value of 1 makes bars touch each other, while smaller values create spacing between bars.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.9)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.5)\nplt.show()\n\n\n\n\n\n\n\n\nWhen using narrower bars, you might want to adjust their position within each bin using the align parameter, which accepts string values. The options are \"mid\" (center-aligned) [and the default], \"left\" (left-aligned), and \"right\" (right-aligned).\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.5, align = \"left\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.5, align = \"right\")\nplt.show()\n\n\n\n\n\n\n\n\nThe color parameter accepts any valid color string and allows you to customize the appearance of your histogram bars.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.9, color = \"green\")\nplt.show()\n\n\n\n\n\n\n\n\nFor multiple datasets, you can specify different colors by providing a list of color strings that corresponds to your list of datasets.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8, histtype = \"barstacked\", color = [\"purple\", \"pink\"])\nplt.show()\n\n\n\n\n\n\n\n\nTo distinguish between different datasets clearly, use the label parameter, which accepts a list of string values. However, labels require an additional step, that being you must call plt.legend() to display the labels properly on your graph.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8, histtype = \"barstacked\", color = [\"purple\", \"pink\"], label = [\"Morning Class\", \"Evening Class\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThis covers the most essential aspects of creating and customizing histograms in matplotlib. Histograms are particularly valuable for understanding the frequency distribution of your data and identifying patterns like skewness, outliers, or multiple peaks that might not be apparent in raw numerical form.\n\n\nUniversal Matplotlib Functions\nBefore diving into specific plot types, it’s essential to understand matplotlib’s universal functions that enhance any visualization. These are functions that work consistently across all graph types.\nThe plt.xlabel() and plt.ylabel() functions accept string values and add descriptive labels to your axes. These labels should clearly indicate the units of measurement and what each axis represents.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Count\")\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.title() function accepts a string value and creates an overall title for your visualization.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.title(\"Grades\")\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.grid() function accepts a boolean value and adds grid lines to your plot when set to True. While not essential for simple visualizations, grid lines can significantly improve readability for larger datasets or more complex plots.\nAdditionally, we can specificy an alpha parameter to determine how transparent our graph lines are.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.grid(True, alpha =.5)\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.text() function provides the ability to add notes directly onto your graph. It accepts several essential parameters: x-coordinate (float), y-coordinate (float), and the text string.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(.1, 4, \"These are the best and worst classes\")\nplt.show()\n\n\n\n\n\n\n\n\nFor more convenient and consistent text positioning, you can use relative coordinates by setting the transform parameter to plt.gca().transAxes. gca stands for “get current axes,” and does exactly this. transAxes changes the units returned by .gac() from direct units into axis relative units, which range on a scale from 0.0 to 1.0.\nUsing this parameter with this input allows you to position text using normalized values between 0 and 1, where (0,0) represents the bottom-left corner and (1,1) represents the top-right corner, regardless of your data’s actual scale. In our case, we will put it in the top right corner.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(1.0, 1.0, \"This is the best class\", transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nHowever, you may notice that it isn’t staying in the corner of our graph. It is actually going outside the graph. To keep our text inside our graph we need to specify a few more variables. Those being, va and ha.\nThe ha (horizontal alignment) and va (vertical alignment) parameters accept string values and provide precise control over text positioning relative to the coordinates. The horizontal alignment parameter accepts \"left\", \"center\", and \"right\" values, while vertical alignment accepts \"bottom\", \"center\", and \"top\" values. These parameters ensure your text doesn’t extend beyond plot boundaries.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(0.95, 0.95, \"This is the best class\", ha = \"right\", va = \"top\", transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.subplots() function enables you to create multiple plots within a single figure, accepting integer values for the number of rows and columns you desire. This function returns both a figure object and an axes array that you can use to place individual plots in an organized layout. A blank one is shown below.\n\nfig, axes = plt.subplots(2, 3)\n\n\n\n\n\n\n\n\nYou access individual subplot positions through indexing by array, where axes[row, column] specifies the exact location for each plot. For our example here, we will use the same plot and simply change the color of each.\n\nfig, axes = plt.subplots(2, 3)\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"lightblue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\n\nplt.show()\n\n\n\n\n\n\n\n\nTo enhance your subplots, use the .set_title() method, which accepts a string value, for individual subplot titles. You can also use plt.suptitle(), also accepting a string, for an overarching title that covers the entire figure. Additionally, the plt.tight_layout() function automatically adjusts spacing between subplots to ensure our plots don’t overlap.\n\nfig, axes = plt.subplots(2, 3)\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThe figsize parameter accepts a tuple of two float values (width, height), measured in inches, and controls the overall dimensions of your figure. Experimenting with different sizes helps you find the optimal display format for your specific visualization needs. I will show you a few different size below, specifically (12,8), (10,6), and (8,4).\n\nfig, axes = plt.subplots(2, 3, figsize = (12, 8))\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig, axes = plt.subplots(2, 3, figsize = (10, 6))\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig, axes = plt.subplots(2, 3, figsize = (8, 4))\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese universal matplotlib functions form the backbone of professional data visualization, transforming basic plots into polished graphics. Mastering these tools will significantly enhance the clarity and impact of every plot you create, regardless of the specific plot type you choose.\n\n\nBoxplot\nBoxplots provide a statistical summary of your data’s distribution, showing the median, quartiles, and potential outliers in a compact visual format. Creating a boxplot is straightforward using plt.boxplot(), and like histograms, you can display data from one or multiple datasets.\n\nplt.boxplot(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot([df[\"gpa\"], more_data])\nplt.show()\n\n\n\n\n\n\n\n\nThe labels parameter accepts a list of string values and helps differentiate multiple datasets in your boxplot, just like we did with histograms.\n\nplt.boxplot([df[\"gpa\"], more_data], labels = [\"Class A\", \"Class B\"])\nplt.legend()\nplt.show()\n\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_23492\\1134656318.py:1: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  plt.boxplot([df[\"gpa\"], more_data], labels = [\"Class A\", \"Class B\"])\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_23492\\1134656318.py:2: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n\n\n\n\n\n\n\n\n\nThe showmeans parameter accepts a boolean value and, when set to True, adds a marker indicating the mean value.\n\nplt.boxplot(df[\"gpa\"], showmeans = True)\nplt.show()\n\n\n\n\n\n\n\n\nThe meanline parameter accepts a boolean value and changes how the mean is displayed. When set to True, it shows the mean as a line across the box rather than a point marker.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = True)\nplt.show()\n\n\n\n\n\n\n\n\nThe vert parameter accepts a boolean value and controls the orientation of your boxplot. Setting it to False creates horizontal boxplots instead of the default vertical ones.\n\nplt.boxplot(df[\"gpa\"], vert = False)\nplt.show()\n\n\n\n\n\n\n\n\nBoxplots offer extensive customization through several property parameters that accept dictionaries containing styling options. The most common properties in these parameters include color, which we’ve already covered, linewidth, which takes float values for line thickness, (and defaults to 1), and linestyle, which accepts string values for line patterns.\nThe boxprops parameter controls the appearance of the main rectangular box that encompasses the first quartile through the third quartile. It accepts a dictionary of properties. Those being, linewidth, linestyle, edgecolor, and facecolor. Unlike most parameters, this one requires a separate parameter be either activated or deactivated for it to work properly. This parameter being patch_artist. This is because facecolor only works when the patch_artist parameter is set to True, while linestyle only works when patch_artist is set to False.\nFirst I will show you a plot with facecolor followed by one showing linestyle. (Also, take note that if you are omitting facecolor, then you can simply change edgecolor to color, since now there is no other color to confuse it with.)\n\nplt.boxplot(df[\"gpa\"], patch_artist = True, boxprops = dict(facecolor = \"red\", edgecolor= \"pink\", linewidth = 2)) \nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot(df[\"gpa\"], patch_artist = False, boxprops = dict(color = \"red\", linestyle = \"--\", linewidth = 2)) \nplt.show()\n\n\n\n\n\n\n\n\nThe linestyle parameter offers several string options for line appearance, those being:\n\n\"-\" → solid line\n\"--\" → dashed line\n\"-.\" → dash-dot line\n\":\" → dotted line\n\"None\" or \"\" → no line\n\nHere’s an example demonstrating different line styles.\n\nfig, axes = plt.subplots(1, 5)\n\naxes[0].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"-\")) \naxes[0].set_title(\"Solid Line\")\naxes[1].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"--\")) \naxes[1].set_title(\"Dashed Line\")\naxes[2].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"-.\")) \naxes[2].set_title(\"Dash-Dot Line\")\naxes[3].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \":\")) \naxes[3].set_title(\"Dotted Line\")\naxes[4].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"\")) \naxes[4].set_title(\"No Line\")\n\nplt.suptitle(\"Line Styles\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThe whiskerprops parameter controls the appearance of the whiskers. It accepts a dictionary with the standard properties of color, linestyle, and linewidth.\n\nplt.boxplot(df[\"gpa\"], whiskerprops = dict(color = \"green\", linestyle = \":\", linewidth = 1))\nplt.show()\n\n\n\n\n\n\n\n\nThe capprops parameter controls the caps at the end of each whisker. It also accepts a dictionary with color, linestyle, and linewidth properties.\n\nplt.boxplot(df[\"gpa\"], capprops = dict(color = \"orange\", linestyle = \"-\", linewidth = 3))\nplt.show()\n\n\n\n\n\n\n\n\nThe flierprops parameter customizes the appearance of outliers in your data and accepts a dictionary with unique properties. The marker parameter accepts string values specifying the shape, which can be any one of the following options:\n\n\"o\" → circle\n\"s\" → square\n\"D\" → diamond\n\"^\" → triangle up\n\"v\" → triangle down\n\"&lt;\" → triangle left\n\"&gt;\" → triangle right\n\"x\" → X\n\"+\" → plus\n\"*\" → star\n\"p\" → pentagon\n\"h\" → hexagon\n\".\" → point (very small)\n\nAdditional properties include markerfacecolor and markeredgecolor (which accepts color strings for fill and edge), and markersize ( which accepts an integer for size):\n\nplt.boxplot(df[\"gpa\"], flierprops = dict(marker = \"*\", markerfacecolor = \"pink\", markeredgecolor = \"red\", markersize = 3))\nplt.show()\n\n\n\n\n\n\n\n\nThe medianprops parameter controls the median line appearance within the box, accepting a dictionary with color, linestyle, and linewidth properties.\n\nplt.boxplot(df[\"gpa\"], medianprops = dict(color = \"lightgreen\", linestyle = \"-.\", linewidth = .75))\nplt.show()\n\n\n\n\n\n\n\n\nThe meanprops parameter customizes the mean marker or line appearance when showmeans is enabled. It accepts a dictionary with the same marker properties as flierprops.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanprops = dict(marker = \"D\", markerfacecolor = \"yellow\", markeredgecolor = \"cyan\", markersize = 6))\nplt.show()\n\n\n\n\n\n\n\n\nWhen using meanline = True, the marker properties apply to markers created at each end of the mean line rather than modifying the line itself.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = True, meanprops = dict(marker = \"X\", markerfacecolor = \"magenta\", markeredgecolor = \"skyblue\", markersize = 10))\nplt.show()\n\n\n\n\n\n\n\n\nTo create multiple customized boxplots on the same graph, use the positions parameter. This accepts a list of integer values specifying where each boxplot should be placed.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = False, meanprops = dict(marker = \"D\", markerfacecolor = \"cyan\", markeredgecolor = \"blue\", markersize = 8), patch_artist = True, boxprops = dict(facecolor = \"lightblue\", edgecolor = \"blue\", linewidth = .5), medianprops = dict(color = \"orange\", linestyle = \"-\", linewidth = 2), flierprops = dict(marker = \"s\", markerfacecolor = \"lightblue\", markeredgecolor = \"blue\", markersize = 6), capprops = dict(color = \"yellow\", linestyle = \"--\", linewidth = 5), positions = [1])\n\nplt.boxplot(more_data, showmeans = True, meanline = False, meanprops = dict(marker = \"D\", markerfacecolor = \"cyan\", markeredgecolor = \"blue\", markersize = 8), patch_artist = True, boxprops = dict(facecolor = \"pink\", edgecolor = \"red\", linewidth = .5), medianprops = dict(color = \"green\", linestyle = \"-\", linewidth = 2), flierprops = dict(marker = \"s\", markerfacecolor = \"pink\", markeredgecolor = \"red\", markersize = 6), capprops = dict(color = \"lightgreen\", linestyle = \"--\", linewidth = 5), positions = [2])\n\nplt.show()\n\n\n\n\n\n\n\n\nThis covers all the fundamental techniques for creating and customizing boxplots in matplotlib. Boxplots excel at providing a statistical summary of your data’s distribution, making them invaluable for quickly identifying outliers, comparing distributions between groups, and understanding the spread and central tendency of your datasets.\n\n\nDensity\nDensity plots are another way to visualize the distribution of a single feature. Unlike histograms which show discrete bins, density plots show a smooth curve that represents the probability density of your data. This makes them particularly useful for understanding the shape of your data distribution.\nTo create a density plot, we use pandas’ built-in .plot(kind='density') method or .plot.density(), as those are the easiest methods. However, they require importing Scipy. This is a scientific computing and technical computing library that pandas uses in order to make these graphs. You don’t need to know the specifics of how it works for this specific tutorial.\n\nimport scipy\n\nFor the following demonstrations, I will be using plot.density(), rather than .plot(kind='density'), simply because I like it more.\n\ndf[\"gpa\"].plot.density()\nplt.show()\n\n\n\n\n\n\n\n\nWe can also change the color of our density plot using the color parameter, just as we have with previous plots.\n\ndf[\"gpa\"].plot.density(color=\"purple\")\nplt.show()\n\n\n\n\n\n\n\n\nIf we want our density plot to be filled in, we don’t have any parameter to set to True, instead we use some special functions from matplotlib.\nFirst we take the plot we are using and place it into a variable. then, we use .lines[], which goes to the axis specified in the brackets, followed by .get_xdata() or .get_ydata(). This will give us the area under the curve.\nFinally, we can use .fill_between() from matplotlib to fill in the area. This functions takes our x and y data, which we got from .get_xdata(), and .get_ydata(), to fill in the plot. Allow me to show what that looks like in actual code.\n\nax = df[\"gpa\"].plot.density()\nx = ax.lines[0].get_xdata()\ny = ax.lines[0].get_ydata()\nax.fill_between(x, y)\nplt.show()\n\n\n\n\n\n\n\n\nJust like with histograms and boxplots, we can plot multiple datasets on the same graph to compare their distributions.\n\ndf[\"gpa\"].plot.density(color=\"blue\", label=\"Class A\")\nmore_data.plot.density(color=\"red\", label=\"Class B\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nWe can also fill in those multiple density plots. However, notice that if you fill them in, that you need to specify your color parameter in the fill_between() function instead of the plot.density() function.\n\nax = df[\"gpa\"].plot.density(label=\"Class A\")\nx = ax.lines[0].get_xdata()\ny = ax.lines[0].get_ydata()\nax.fill_between(x, y, color=\"blue\",)\n\nmore_data.plot.density(label=\"Class B\")\n\nx2 = ax.lines[1].get_xdata()\ny2 = ax.lines[1].get_ydata()\nax.fill_between(x2, y2, color=\"red\")\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nHowever, you might notice its a bit harder to see the entire graph when they are both filled. If we want to make them more transparent, we can use the alpha parameter, which accepts a float between 0 and 1. Values closer to 0 create more transparency, while values closer to 1 make the plot more opaque. (The same comment I made about setting the color of a filled in graph also applies here with alpha.)\n\nax = df[\"gpa\"].plot.density(label=\"Class A\")\nx = ax.lines[0].get_xdata()\ny = ax.lines[0].get_ydata()\nax.fill_between(x, y, color=\"blue\", alpha=0.5)\n\nmore_data.plot.density(label=\"Class B\")\n\nx2 = ax.lines[1].get_xdata()\ny2 = ax.lines[1].get_ydata()\nax.fill_between(x2, y2, color=\"red\", alpha=0.5)\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nOne of the most important parameters for density plots is bw_method, which accepts a float or string value. This parameter affects how smooth or detailed your curve appears. A smaller float (like 0.1) creates a more detailed, jagged curve that follows the data closely, while a larger float (like 0.5) creates a smoother, more generalized curve. The string options include 'scott' and 'silverman'.\nI will demonstrate by showing each of the methods.\n\ndf[\"gpa\"].plot.density(bw_method=0.1, label=\"Low Float\")\nplt.legend() \nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(bw_method=0.5, label=\"High Float\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(bw_method=\"scott\", label=\"Scott\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(bw_method=\"silverman\", label=\"Silverman\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nWe can control the style of the line using the linestyle parameter, which is the same as in previous graphs.\n\ndf[\"gpa\"].plot.density(linestyle=\"--\", color=\"green\")\nplt.show()\n\n\n\n\n\n\n\n\nThe linewidth parameter is the same as with previous graphs.\n\ndf[\"gpa\"].plot.density(linewidth=0.5, label=\"Thin Line\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(linewidth=3, label=\"Thick Line\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFor density plots, we can also specify the range of x-values we want to plot using xlim, which accepts a tuple of two float values (min, max). This parameter is particularly useful when comparing datasets with different ranges, as it allows you to focus on a specific portion of the distribution or standardize the viewing window across multiple plots.\nIt also has an equivalent function for y called ylim.\n\ndf[\"gpa\"].plot.density(xlim=(0, 4), color=\"blue\")\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(ylim=(0, 1), color=\"blue\")\nplt.show()\n\n\n\n\n\n\n\n\nFinally, let’s put everything together to create a comprehensive density plot with all the customizations we’ve learned:\n\ndf[\"gpa\"].plot.density(color=\"purple\", alpha=0.6, xlim=(0,4), ylim=(0,1), linewidth=3, linestyle=\"-\", label=\"Morning Class\")\nmore_data.plot.density(color=\"orange\", alpha=0.6, xlim=(0,4), ylim=(0,1), linewidth=3, linestyle=\"--\", label=\"Evening Class\")\n\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Density\")\nplt.title(\"Student GPA Distribution Analysis\")\nplt.legend(loc=\"upper left\")\nplt.grid(True, alpha=0.3)\nplt.text(0.95, 0.95, \"Density shows probability distribution\", ha=\"right\", va=\"top\", transform=plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nThis covers all the essential aspects of creating density plots in matplotlib. Density plots are particularly useful when you want to see the smooth distribution of your data and compare the shapes of multiple datasets without the discrete bins that histograms create."
  },
  {
    "objectID": "blog.html#conclusion",
    "href": "blog.html#conclusion",
    "title": "An Introduction to Visualizations in Python",
    "section": "Conclusion",
    "text": "Conclusion\nThroughout this tutorial, you’ve developed essential data visualization skills that will transform how you analyze and present information. You’ve learned the art of creating histograms, boxplots, and density plots.\nHowever, how do you know when to actually use these plots? It depends on the characteristics of your data and your analytical goals. If you are examining the shape and frequency distribution of your features, then use histograms. If you need to see what the cumulative count is in your datasets, use a stacked histogram. If you are interested in specific statistical view of your data, then you can use boxplots to view the the variability and outliers in your data. You can even compare how it differs across different groups of data. If you need a smooth looking representation of your graph’s shape, then consider using density plots, especially if you need to overlay multiple datasets on top of each other. Examining your data, your goals, and your available plots can help you find the best one for hte job.\nThis tutorial is intended to be a general introduction to some of matplotlib’s plots and the most important parameters in each. As I have said before, not all parameters are included. If you want more information on how matplotlib’s graphs, then I refer you to their plot page, which contains all their plots: Matplotlib_plots\nI encourage you to use the skills you learned here in making these plots to go and try to craft some of the other plots, such as a violin plot or a stem plot. I highly suggest that you open up your own python file and begin experimenting with, not just the graphs that I have given you, but all the graphs that matplotlib has to offer. Knowing what kind of plots there are and how to use them, will make it far easier when you need to select a plot in the future for your data. Additionally, coding up that plot, and coding it up to look nice, will be far easier if you have some practice and knowledge beforehand.\nIf you are even more interested in plotting and want to go further, then I recommend Seaborn. This is a library that is built on top of matplotlib that allows you further enhance the aesthetics of your visualizations. You can find the introduction to Seaborn here: Seaborn_introduction\nAdditionally, if you want to use some real datasets from off the internet, rather than simply creating your own data to work with, then I recommend using Zenodo. They offer thousands of open source datasets that you can download and use to further your visualization skills. You can find some datasets from them here: Zenodo_datasets\nIn fact, I highly recommend finding a dataset that you like and believe you can model, and using some of the plots that we have described here to visualize that data and better understand it.\nRemember, a critical step in understanding data, is actually being able to see the data. Have fun visualizing!\n(Plans are in the works for a blog post are visualizing the relationship between features, so keep an eye out for that!) -Cassandra"
  },
  {
    "objectID": "blog2.html#introduction",
    "href": "blog2.html#introduction",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "Hello again. In my previous visualization post we discussed how to plot graphs when you are looking at exactly 1 feature, this time we will continue our learning by moving on to 2 features and further!"
  },
  {
    "objectID": "blog2.html#pandas",
    "href": "blog2.html#pandas",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "Before we begin, we need to download a dataset to work with. To do so, we will be using …\n\n\n\nNow we will find out exactly what data we are working with. By this, I mean that we will check exactly how the information is stored within our DataFrame."
  },
  {
    "objectID": "blog2.html#relationship-graphs-2-features",
    "href": "blog2.html#relationship-graphs-2-features",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "In a previous post we’ve looked at visualizations that focus on one variable at a time. These are great for showing distributions, but often in data science, what we care about is the relationship between at least two variables.\nIn this section, we’ll cover how to use matplotlib to show relationships between pairs of features in our dataset.\nThe first type of plot we’ll cover is the scatter plot."
  },
  {
    "objectID": "blog2.html#d-graphs",
    "href": "blog2.html#d-graphs",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "For this section, we will only cover how to use the scatterplot we are familiar with to move from a 2D into a 3D setting."
  }
]