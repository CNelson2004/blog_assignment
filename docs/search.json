[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Data Science Blog",
    "section": "",
    "text": "Welcome to my blog!\nHere, not only do I care about data, but I care about how it is shown. Therefore, the main point of this blog is on the visualization of data through libraries such as Matplotlib and Seaborn, but you can also find posts about how to manipulate data with Pandas and Numpy. Currently the posts only cover visualization, since that is what I am most interested in. Rest assured, after reading my blog posts, don’t simply expect to know how to use these libraries by reading these posts, but expect to be able to use them well.\nConcerning our visualization blog posts. Currently, this blog covers the basic of Matplotlib. The first blog post, (An Introduction to Visualizations in Python), shows you how to plot a single factor, even if that factor exists in multiple datasets. Additionally, it gives an in-depth coverage of basic plots, such as histograms, boxplots, and density functions. If you have read that post, then you understand how in depth I go into every function so that way you not only can use the plotting functions, but can customize them to look however you wish. You can expect this same quality in future blog posts.\nAdditionally, since it is an introductory post, you will also find the basics of creating a small dataset to play with pandas, and some universal Matplotlib functions that apply to any graph that you are creating.\nIn our second post I will continue to explore Matplotlib by looking at graphs that show two features against each other, such as in scatter plots, and explain them easily enough for you to use them in any situation you need them. Additionally, we will show how to use pandas to retrieve a dataset from the web, which you can then use in your visualization journey as you experiment with various graphs and visualization techniques.\nFor future posts, expect to see more matplotlib, and then enhancing the graphs we learned from Matplotlib with Seaborn. There may also be a few smaller posts regarding extra Pandas and Numpy features.\nWith that said, please choose a topic in the header and enjoy learning!\nIf you would prefer to learn more about me, then head over the the ‘About Me’ page instead"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "An Introduction to Visualizations in Python",
    "section": "",
    "text": "When working with data you can only get so far with the raw numbers alone. It’s difficult to perform any introductory analysis when you can’t see what data you are working with, and if you can’t see the data you can’t understand it.\nData visualization transforms raw numbers into meaningful insights that drive better decision-making. In this comprehensive tutorial, you’ll master the essential skills of creating clear, informative visualizations using pandas and matplotlib.\nWe’ll start by creating a dataset in pandas. Then we’ll explore three fundamental distribution plots: histograms, boxplots, and density plots alongside matplotlib’s universal functions that enhance any plt. Each section builds upon the previous one, progressing from basic plot creation to advanced customization techniques that will make your visualizations both professional and impactful.\nBy the end of this tutorial, you’ll have the knowledge and confidence to transform any dataset into compelling visual stories that clearly communicate your data’s most important patterns and insights.\n(A future blog post will cover downloading a dataset into pandas, and plotting graphs for the relationship between two or more features.)"
  },
  {
    "objectID": "blog.html#introduction",
    "href": "blog.html#introduction",
    "title": "An Introduction to Visualizations in Python",
    "section": "",
    "text": "When working with data you can only get so far with the raw numbers alone. It’s difficult to perform any introductory analysis when you can’t see what data you are working with, and if you can’t see the data you can’t understand it.\nData visualization transforms raw numbers into meaningful insights that drive better decision-making. In this comprehensive tutorial, you’ll master the essential skills of creating clear, informative visualizations using pandas and matplotlib.\nWe’ll start by creating a dataset in pandas. Then we’ll explore three fundamental distribution plots: histograms, boxplots, and density plots alongside matplotlib’s universal functions that enhance any plt. Each section builds upon the previous one, progressing from basic plot creation to advanced customization techniques that will make your visualizations both professional and impactful.\nBy the end of this tutorial, you’ll have the knowledge and confidence to transform any dataset into compelling visual stories that clearly communicate your data’s most important patterns and insights.\n(A future blog post will cover downloading a dataset into pandas, and plotting graphs for the relationship between two or more features.)"
  },
  {
    "objectID": "blog.html#learning-pandas",
    "href": "blog.html#learning-pandas",
    "title": "An Introduction to Visualizations in Python",
    "section": "Learning Pandas",
    "text": "Learning Pandas\n\nCreating a dataset\nIn order to visualize data effectively, we first need to obtain some. We’ll use pandas to create a small, manageable dataset that will serve as our foundation for learning visualization techniques.\nWe begin by importing our essential libraries. those being pandas for data manipulation and matplotlib for creating visualizations.\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nNow we’ll design our dataset structure by deciding on the number of features (which will become our columns). For this example, our dataset will have 4 features: name, gpa, major, and year. We’ll also determine the size of our dataset, which in this case will be 10. Ten entries will provide enough data to demonstrate various visualization techniques without overwhelming complexity.\nTo create this dataset programmatically, we’ll first construct 4 lists containing 10 items each.\n\nname = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Ethan\", \"Fiona\", \"George\", \"Hannah\", \"Isaac\", \"Julia\"]\n\ngpa = [3.5, 2.8, 3.9, 3.2, 2.5, 1.4, 2.9, 3.8, 2.2, 3.6]  \n\nmajor = [\"Math\", \"Computer Science\", \"Statistics\", \"Math\", \"Computer Science\", \"Statistics\", \"Math\", \"Computer Science\", \"Statistics\", \"Math\"]\n\nyear = [\"Freshman\", \"Sophomore\", \"Junior\", \"Senior\", \"Freshman\", \"Sophomore\", \"Junior\", \"Senior\", \"Freshman\", \"Sophomore\"]\n\nNow that we have our feature data prepared, we’ll combine them into a pandas DataFrame using a dictionary structure. The pd.DataFrame() constructor accepts a dictionary where keys become column names and values become the column data, providing the structured format necessary for effective data analysis and visualization.\n\ndata = {\n    \"name\": name, \n    \"gpa\": gpa, \n    \"major\": major, \n    \"year\": year\n}\n\ndf = pd.DataFrame(data)\n\n\n\nInspecting a dataset\nBefore creating visualizations, it’s crucial to understand your data’s structure and contents. Pandas provides several powerful methods for data exploration and inspection, each serving different analytical needs.\nThe .head() method accepts an optional integer parameter (default value is 5) and displays that number of rows of your dataset. This function provides a quick preview of your data’s structure and content, helping you verify that your data loaded correctly and understand the format of each column.\n(This isn’t particularly helpful when we have created our own dataset by hand, but if you download a dataset, or simply create a much larger one that has more randomness to it, then this is still useful to ensure it is all correctly formatted.)\n\ndf.head()\n\n\n\n\n\n\n\n\nname\ngpa\nmajor\nyear\n\n\n\n\n0\nAlice\n3.5\nMath\nFreshman\n\n\n1\nBob\n2.8\nComputer Science\nSophomore\n\n\n2\nCharlie\n3.9\nStatistics\nJunior\n\n\n3\nDiana\n3.2\nMath\nSenior\n\n\n4\nEthan\n2.5\nComputer Science\nFreshman\n\n\n\n\n\n\n\nTo view the entire dataset, you can use the print() function, which displays all rows and columns. This approach is particularly useful for smaller datasets where you want to see every data point. However, it isn’t really viable for larger datasets, which is why you would use .head().\n\nprint(df)\n\n      name  gpa             major       year\n0    Alice  3.5              Math   Freshman\n1      Bob  2.8  Computer Science  Sophomore\n2  Charlie  3.9        Statistics     Junior\n3    Diana  3.2              Math     Senior\n4    Ethan  2.5  Computer Science   Freshman\n5    Fiona  1.4        Statistics  Sophomore\n6   George  2.9              Math     Junior\n7   Hannah  3.8  Computer Science     Senior\n8    Isaac  2.2        Statistics   Freshman\n9    Julia  3.6              Math  Sophomore\n\n\nFor examining specific features, you can access individual columns by using bracket notation with the column name as a string. This operation returns a pandas Series containing all values from that column, making it easy to focus on particular variables.\n\ndf[\"gpa\"]\n\n0    3.5\n1    2.8\n2    3.9\n3    3.2\n4    2.5\n5    1.4\n6    2.9\n7    3.8\n8    2.2\n9    3.6\nName: gpa, dtype: float64\n\n\nThe .loc function provides another method of obtaining columns by using label-based indexing. It accepts row and column specifications separated by a comma, where the first parameter specifies rows and the second specifies columns.\nUsing : (which you may be familiar with from Python) selects all rows, while providing a list of string column names selects specific columns. This method is particularly good for looking at multiple columns simultaneously.\n\ndf.loc[:, [\"name\", \"gpa\"]]\n\n\n\n\n\n\n\n\nname\ngpa\n\n\n\n\n0\nAlice\n3.5\n\n\n1\nBob\n2.8\n\n\n2\nCharlie\n3.9\n\n\n3\nDiana\n3.2\n\n\n4\nEthan\n2.5\n\n\n5\nFiona\n1.4\n\n\n6\nGeorge\n2.9\n\n\n7\nHannah\n3.8\n\n\n8\nIsaac\n2.2\n\n\n9\nJulia\n3.6\n\n\n\n\n\n\n\nThe .iloc function performs integer-location based selection, allowing you to access rows by their numerical index position. It accepts integer values corresponding to row positions (starting from 0), making it ideal for retrieving specific rows.\n\ndf.iloc[0]\n\nname        Alice\ngpa           3.5\nmajor        Math\nyear     Freshman\nName: 0, dtype: object\n\n\nFor conditional data selection, you can combine boolean indexing with .loc. This approach filters rows based on specific criteria. For example, you can find all rows where a particular column equals a certain value, as demonstrated below.\n\ndf.loc[df[\"name\"] == \"Alice\"]\n\n\n\n\n\n\n\n\nname\ngpa\nmajor\nyear\n\n\n\n\n0\nAlice\n3.5\nMath\nFreshman\n\n\n\n\n\n\n\nThis foundational knowledge of pandas data manipulation and inspection provides the essential tools you need to effectively prepare, explore, and understand your data before creating your visualizations."
  },
  {
    "objectID": "blog.html#distribution-graphs-1-feature",
    "href": "blog.html#distribution-graphs-1-feature",
    "title": "An Introduction to Visualizations in Python",
    "section": "Distribution Graphs (1 Feature)",
    "text": "Distribution Graphs (1 Feature)\nFirst we will show how you can plot a single feature with various distribution graphs.\n\nHistogram\nThe first visualization we’ll explore is a histogram, which displays the frequency distribution of our data by dividing it into bins. For this example, we’ll examine the distribution of GPA values from our dataset.\nWe create histograms using plt.hist(), which automatically counts how many data points fall into each range and displays them as bars. To plot only the GPA values, we’ll extract all the information from the gpa column.\nAn essential aspect of using matplotlib is that you should always use the .show() function after creating a graph. Without it, you’ll see unwanted return text that clutters your visualization. Allow me demonstrate the difference.\n\nplt.hist(df[\"gpa\"])\n\n(array([1., 0., 0., 1., 1., 1., 1., 1., 2., 2.]),\n array([1.4 , 1.65, 1.9 , 2.15, 2.4 , 2.65, 2.9 , 3.15, 3.4 , 3.65, 3.9 ]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\nYou may notice that even the clean version above doesn’t look optimal, the x-axis ranges from 1.4 to 3.9. This happens because we haven’t specified the optional bins and range parameters.\nThe bins parameter accepts an integer and determines how many equal-width intervals your data is divided into. If not specified, matplotlib automatically creates 10 evenly spaced bins. The range parameter accepts a tuple of two float values (min, max) and sets the boundaries for your histogram. If not specified, it uses the natural minimum and maximum of your data.\nHowever, since we know that GPAs typically range from 0.0 to 4.0, we can adjust our visualization accordingly.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0))\nplt.show()\n\n\n\n\n\n\n\n\nNow that our data is more accurately represented within the proper GPA scale, let’s explore how different numbers of bins affect the visualization.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 4)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.show()\n\n\n\n\n\n\n\n\nThese aren’t the only customization options for histograms. The orientation parameter accepts string values and controls whether bars are displayed vertically or horizontally, with the graph defaulting to vertical.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, orientation = \"horizontal\")\nplt.show()\n\n\n\n\n\n\n\n\nCurrently, the y-axis shows the count of values falling into each bin. We can change this to display the probability density by setting the density parameter, which accepts a boolean value. When set to True, the histogram shows the relative frequency rather than absolute counts.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, density = True)\nplt.show()\n\n\n\n\n\n\n\n\nAt first glance, this might seem incorrect since the heights don’t appear to sum to 1. This is because you need to consider both the height and width of each bin. Since each bin is 0.5 units wide, multiplying each bin’s height by 0.5 and summing them gives us 1. Each bin’s area represents the percentage of data within that range.\nThe histtype parameter accepts string values and specifies the visual style of your histogram bars. There are four options: \"bar\" (default solid bars), \"step\" (unfilled outlines), \"stepfilled\" (filled step plots), and \"barstacked\" (for multiple datasets). Allow me to show you each.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"step\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"stepfilled\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\")\nplt.show()\n\n\n\n\n\n\n\n\nAt first \"bar\" and \"stepfilled\" might appear exactly the same. However, the difference becomes more apparent when we add edge lines using the edgecolor parameter, which accepts any valid matplotlib color string.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"stepfilled\", edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", edgecolor = \"black\")\nplt.show()\n\n\n\n\n\n\n\n\nThe \"barstacked\" option is designed for comparing multiple datasets by stacking their bars. To demonstrate this properly, we need additional data. Since we’re focusing on a single feature, we’ll create a simple pandas Series.\n\nmore_data = pd.Series([2.3, 3.8, 1.4, 2.9, 3.5, 1.8, 2.1, 3.0, 1.2, 0.9])\n\nNow we can properly demonstrate the barstacked histogram.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8, histtype = \"barstacked\")\nplt.show()\n\n\n\n\n\n\n\n\nThe rwidth parameter accepts a float value between 0 and 1 and controls the relative width of the bars. The default value of 1 makes bars touch each other, while smaller values create spacing between bars.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.9)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.5)\nplt.show()\n\n\n\n\n\n\n\n\nWhen using narrower bars, you might want to adjust their position within each bin using the align parameter, which accepts string values. The options are \"mid\" (center-aligned) [and the default], \"left\" (left-aligned), and \"right\" (right-aligned).\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.5, align = \"left\")\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.5, align = \"right\")\nplt.show()\n\n\n\n\n\n\n\n\nThe color parameter accepts any valid color string and allows you to customize the appearance of your histogram bars.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, histtype = \"bar\", rwidth = 0.9, color = \"green\")\nplt.show()\n\n\n\n\n\n\n\n\nFor multiple datasets, you can specify different colors by providing a list of color strings that corresponds to your list of datasets.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8, histtype = \"barstacked\", color = [\"purple\", \"pink\"])\nplt.show()\n\n\n\n\n\n\n\n\nTo distinguish between different datasets clearly, use the label parameter, which accepts a list of string values. However, labels require an additional step, that being you must call plt.legend() to display the labels properly on your graph.\n\nplt.hist([df[\"gpa\"], more_data], range = (0.0, 4.0), bins = 8, histtype = \"barstacked\", color = [\"purple\", \"pink\"], label = [\"Morning Class\", \"Evening Class\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThis covers the most essential aspects of creating and customizing histograms in matplotlib. Histograms are particularly valuable for understanding the frequency distribution of your data and identifying patterns like skewness, outliers, or multiple peaks that might not be apparent in raw numerical form.\n\n\nUniversal Matplotlib Functions\nBefore diving into specific plot types, it’s essential to understand matplotlib’s universal functions that enhance any visualization. These are functions that work consistently across all graph types.\nThe plt.xlabel() and plt.ylabel() functions accept string values and add descriptive labels to your axes. These labels should clearly indicate the units of measurement and what each axis represents.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Count\")\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.title() function accepts a string value and creates an overall title for your visualization.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.title(\"Grades\")\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.grid() function accepts a boolean value and adds grid lines to your plot when set to True. While not essential for simple visualizations, grid lines can significantly improve readability for larger datasets or more complex plots.\nAdditionally, we can specificy an alpha parameter to determine how transparent our graph lines are.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.grid(True, alpha =.5)\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.text() function provides the ability to add notes directly onto your graph. It accepts several essential parameters: x-coordinate (float), y-coordinate (float), and the text string.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(.1, 4, \"These are the best and worst classes\")\nplt.show()\n\n\n\n\n\n\n\n\nFor more convenient and consistent text positioning, you can use relative coordinates by setting the transform parameter to plt.gca().transAxes. gca stands for “get current axes,” and does exactly this. transAxes changes the units returned by .gac() from direct units into axis relative units, which range on a scale from 0.0 to 1.0.\nUsing this parameter with this input allows you to position text using normalized values between 0 and 1, where (0,0) represents the bottom-left corner and (1,1) represents the top-right corner, regardless of your data’s actual scale. In our case, we will put it in the top right corner.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(1.0, 1.0, \"This is the best class\", transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nHowever, you may notice that it isn’t staying in the corner of our graph. It is actually going outside the graph. To keep our text inside our graph we need to specify a few more variables. Those being, va and ha.\nThe ha (horizontal alignment) and va (vertical alignment) parameters accept string values and provide precise control over text positioning relative to the coordinates. The horizontal alignment parameter accepts \"left\", \"center\", and \"right\" values, while vertical alignment accepts \"bottom\", \"center\", and \"top\" values. These parameters ensure your text doesn’t extend beyond plot boundaries.\n\nplt.hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8)\nplt.text(0.95, 0.95, \"This is the best class\", ha = \"right\", va = \"top\", transform = plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nThe plt.subplots() function enables you to create multiple plots within a single figure, accepting integer values for the number of rows and columns you desire. This function returns both a figure object and an axes array that you can use to place individual plots in an organized layout. A blank one is shown below.\n\nfig, axes = plt.subplots(2, 3)\n\n\n\n\n\n\n\n\nYou access individual subplot positions through indexing by array, where axes[row, column] specifies the exact location for each plot. For our example here, we will use the same plot and simply change the color of each.\n\nfig, axes = plt.subplots(2, 3)\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"lightblue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\n\nplt.show()\n\n\n\n\n\n\n\n\nTo enhance your subplots, use the .set_title() method, which accepts a string value, for individual subplot titles. You can also use plt.suptitle(), also accepting a string, for an overarching title that covers the entire figure. Additionally, the plt.tight_layout() function automatically adjusts spacing between subplots to ensure our plots don’t overlap.\n\nfig, axes = plt.subplots(2, 3)\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThe figsize parameter accepts a tuple of two float values (width, height), measured in inches, and controls the overall dimensions of your figure. Experimenting with different sizes helps you find the optimal display format for your specific visualization needs. I will show you a few different size below, specifically (12,8), (10,6), and (8,4).\n\nfig, axes = plt.subplots(2, 3, figsize = (12, 8))\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig, axes = plt.subplots(2, 3, figsize = (10, 6))\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\nfig, axes = plt.subplots(2, 3, figsize = (8, 4))\n\naxes[0, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"blue\")\naxes[0, 0].set_title(\"Class Blue\")\naxes[0, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"yellow\")\naxes[0, 1].set_title(\"Class Yellow\")\naxes[0, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"teal\")\naxes[0, 2].set_title(\"Class Teal\")\naxes[1, 0].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"magenta\")\naxes[1, 0].set_title(\"Class Magenta\")\naxes[1, 1].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"cyan\")\naxes[1, 1].set_title(\"Class Cyan\")\naxes[1, 2].hist(df[\"gpa\"], range = (0.0, 4.0), bins = 8, color = \"brown\")\naxes[1, 2].set_title(\"Class Brown\")\n\nplt.suptitle(\"Some graph colors\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese universal matplotlib functions form the backbone of professional data visualization, transforming basic plots into polished graphics. Mastering these tools will significantly enhance the clarity and impact of every plot you create, regardless of the specific plot type you choose.\n\n\nBoxplot\nBoxplots provide a statistical summary of your data’s distribution, showing the median, quartiles, and potential outliers in a compact visual format. Creating a boxplot is straightforward using plt.boxplot(), and like histograms, you can display data from one or multiple datasets.\n\nplt.boxplot(df[\"gpa\"])\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot([df[\"gpa\"], more_data])\nplt.show()\n\n\n\n\n\n\n\n\nThe labels parameter accepts a list of string values and helps differentiate multiple datasets in your boxplot, just like we did with histograms.\n\nplt.boxplot([df[\"gpa\"], more_data], labels = [\"Class A\", \"Class B\"])\nplt.legend()\nplt.show()\n\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_20912\\1134656318.py:1: MatplotlibDeprecationWarning:\n\nThe 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n\nC:\\Users\\cnels\\AppData\\Local\\Temp\\ipykernel_20912\\1134656318.py:2: UserWarning:\n\nNo artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n\n\n\n\n\n\n\n\n\n\nThe showmeans parameter accepts a boolean value and, when set to True, adds a marker indicating the mean value.\n\nplt.boxplot(df[\"gpa\"], showmeans = True)\nplt.show()\n\n\n\n\n\n\n\n\nThe meanline parameter accepts a boolean value and changes how the mean is displayed. When set to True, it shows the mean as a line across the box rather than a point marker.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = True)\nplt.show()\n\n\n\n\n\n\n\n\nThe vert parameter accepts a boolean value and controls the orientation of your boxplot. Setting it to False creates horizontal boxplots instead of the default vertical ones.\n\nplt.boxplot(df[\"gpa\"], vert = False)\nplt.show()\n\n\n\n\n\n\n\n\nBoxplots offer extensive customization through several property parameters that accept dictionaries containing styling options. The most common properties in these parameters include color, which we’ve already covered, linewidth, which takes float values for line thickness, (and defaults to 1), and linestyle, which accepts string values for line patterns.\nThe boxprops parameter controls the appearance of the main rectangular box that encompasses the first quartile through the third quartile. It accepts a dictionary of properties. Those being, linewidth, linestyle, edgecolor, and facecolor. Unlike most parameters, this one requires a separate parameter be either activated or deactivated for it to work properly. This parameter being patch_artist. This is because facecolor only works when the patch_artist parameter is set to True, while linestyle only works when patch_artist is set to False.\nFirst I will show you a plot with facecolor followed by one showing linestyle. (Also, take note that if you are omitting facecolor, then you can simply change edgecolor to color, since now there is no other color to confuse it with.)\n\nplt.boxplot(df[\"gpa\"], patch_artist = True, boxprops = dict(facecolor = \"red\", edgecolor= \"pink\", linewidth = 2)) \nplt.show()\n\n\n\n\n\n\n\n\n\nplt.boxplot(df[\"gpa\"], patch_artist = False, boxprops = dict(color = \"red\", linestyle = \"--\", linewidth = 2)) \nplt.show()\n\n\n\n\n\n\n\n\nThe linestyle parameter offers several string options for line appearance, those being:\n\n\"-\" → solid line\n\"--\" → dashed line\n\"-.\" → dash-dot line\n\":\" → dotted line\n\"None\" or \"\" → no line\n\nHere’s an example demonstrating different line styles.\n\nfig, axes = plt.subplots(1, 5)\n\naxes[0].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"-\")) \naxes[0].set_title(\"Solid Line\")\naxes[1].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"--\")) \naxes[1].set_title(\"Dashed Line\")\naxes[2].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"-.\")) \naxes[2].set_title(\"Dash-Dot Line\")\naxes[3].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \":\")) \naxes[3].set_title(\"Dotted Line\")\naxes[4].boxplot(df[\"gpa\"], boxprops = dict(color = \"red\", linewidth = 4, linestyle = \"\")) \naxes[4].set_title(\"No Line\")\n\nplt.suptitle(\"Line Styles\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThe whiskerprops parameter controls the appearance of the whiskers. It accepts a dictionary with the standard properties of color, linestyle, and linewidth.\n\nplt.boxplot(df[\"gpa\"], whiskerprops = dict(color = \"green\", linestyle = \":\", linewidth = 1))\nplt.show()\n\n\n\n\n\n\n\n\nThe capprops parameter controls the caps at the end of each whisker. It also accepts a dictionary with color, linestyle, and linewidth properties.\n\nplt.boxplot(df[\"gpa\"], capprops = dict(color = \"orange\", linestyle = \"-\", linewidth = 3))\nplt.show()\n\n\n\n\n\n\n\n\nThe flierprops parameter customizes the appearance of outliers in your data and accepts a dictionary with unique properties. The marker parameter accepts string values specifying the shape, which can be any one of the following options:\n\n\"o\" → circle\n\"s\" → square\n\"D\" → diamond\n\"^\" → triangle up\n\"v\" → triangle down\n\"&lt;\" → triangle left\n\"&gt;\" → triangle right\n\"x\" → X\n\"+\" → plus\n\"*\" → star\n\"p\" → pentagon\n\"h\" → hexagon\n\".\" → point (very small)\n\nAdditional properties include markerfacecolor and markeredgecolor (which accepts color strings for fill and edge), and markersize ( which accepts an integer for size):\n\nplt.boxplot(df[\"gpa\"], flierprops = dict(marker = \"*\", markerfacecolor = \"pink\", markeredgecolor = \"red\", markersize = 3))\nplt.show()\n\n\n\n\n\n\n\n\nThe medianprops parameter controls the median line appearance within the box, accepting a dictionary with color, linestyle, and linewidth properties.\n\nplt.boxplot(df[\"gpa\"], medianprops = dict(color = \"lightgreen\", linestyle = \"-.\", linewidth = .75))\nplt.show()\n\n\n\n\n\n\n\n\nThe meanprops parameter customizes the mean marker or line appearance when showmeans is enabled. It accepts a dictionary with the same marker properties as flierprops.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanprops = dict(marker = \"D\", markerfacecolor = \"yellow\", markeredgecolor = \"cyan\", markersize = 6))\nplt.show()\n\n\n\n\n\n\n\n\nWhen using meanline = True, the marker properties apply to markers created at each end of the mean line rather than modifying the line itself.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = True, meanprops = dict(marker = \"X\", markerfacecolor = \"magenta\", markeredgecolor = \"skyblue\", markersize = 10))\nplt.show()\n\n\n\n\n\n\n\n\nTo create multiple customized boxplots on the same graph, use the positions parameter. This accepts a list of integer values specifying where each boxplot should be placed.\n\nplt.boxplot(df[\"gpa\"], showmeans = True, meanline = False, meanprops = dict(marker = \"D\", markerfacecolor = \"cyan\", markeredgecolor = \"blue\", markersize = 8), patch_artist = True, boxprops = dict(facecolor = \"lightblue\", edgecolor = \"blue\", linewidth = .5), medianprops = dict(color = \"orange\", linestyle = \"-\", linewidth = 2), flierprops = dict(marker = \"s\", markerfacecolor = \"lightblue\", markeredgecolor = \"blue\", markersize = 6), capprops = dict(color = \"yellow\", linestyle = \"--\", linewidth = 5), positions = [1])\n\nplt.boxplot(more_data, showmeans = True, meanline = False, meanprops = dict(marker = \"D\", markerfacecolor = \"cyan\", markeredgecolor = \"blue\", markersize = 8), patch_artist = True, boxprops = dict(facecolor = \"pink\", edgecolor = \"red\", linewidth = .5), medianprops = dict(color = \"green\", linestyle = \"-\", linewidth = 2), flierprops = dict(marker = \"s\", markerfacecolor = \"pink\", markeredgecolor = \"red\", markersize = 6), capprops = dict(color = \"lightgreen\", linestyle = \"--\", linewidth = 5), positions = [2])\n\nplt.show()\n\n\n\n\n\n\n\n\nThis covers all the fundamental techniques for creating and customizing boxplots in matplotlib. Boxplots excel at providing a statistical summary of your data’s distribution, making them invaluable for quickly identifying outliers, comparing distributions between groups, and understanding the spread and central tendency of your datasets.\n\n\nDensity\nDensity plots are another way to visualize the distribution of a single feature. Unlike histograms which show discrete bins, density plots show a smooth curve that represents the probability density of your data. This makes them particularly useful for understanding the shape of your data distribution.\nTo create a density plot, we use pandas’ built-in .plot(kind='density') method or .plot.density(), as those are the easiest methods. However, they require importing Scipy. This is a scientific computing and technical computing library that pandas uses in order to make these graphs. You don’t need to know the specifics of how it works for this specific tutorial.\n\nimport scipy\n\nFor the following demonstrations, I will be using plot.density(), rather than .plot(kind='density'), simply because I like it more.\n\ndf[\"gpa\"].plot.density()\nplt.show()\n\n\n\n\n\n\n\n\nWe can also change the color of our density plot using the color parameter, just as we have with previous plots.\n\ndf[\"gpa\"].plot.density(color=\"purple\")\nplt.show()\n\n\n\n\n\n\n\n\nIf we want our density plot to be filled in, we don’t have any parameter to set to True, instead we use some special functions from matplotlib.\nFirst we take the plot we are using and place it into a variable. then, we use .lines[], which goes to the axis specified in the brackets, followed by .get_xdata() or .get_ydata(). This will give us the area under the curve.\nFinally, we can use .fill_between() from matplotlib to fill in the area. This functions takes our x and y data, which we got from .get_xdata(), and .get_ydata(), to fill in the plot. Allow me to show what that looks like in actual code.\n\nax = df[\"gpa\"].plot.density()\nx = ax.lines[0].get_xdata()\ny = ax.lines[0].get_ydata()\nax.fill_between(x, y)\nplt.show()\n\n\n\n\n\n\n\n\nJust like with histograms and boxplots, we can plot multiple datasets on the same graph to compare their distributions.\n\ndf[\"gpa\"].plot.density(color=\"blue\", label=\"Class A\")\nmore_data.plot.density(color=\"red\", label=\"Class B\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nWe can also fill in those multiple density plots. However, notice that if you fill them in, that you need to specify your color parameter in the fill_between() function instead of the plot.density() function.\n\nax = df[\"gpa\"].plot.density(label=\"Class A\")\nx = ax.lines[0].get_xdata()\ny = ax.lines[0].get_ydata()\nax.fill_between(x, y, color=\"blue\",)\n\nmore_data.plot.density(label=\"Class B\")\n\nx2 = ax.lines[1].get_xdata()\ny2 = ax.lines[1].get_ydata()\nax.fill_between(x2, y2, color=\"red\")\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nHowever, you might notice its a bit harder to see the entire graph when they are both filled. If we want to make them more transparent, we can use the alpha parameter, which accepts a float between 0 and 1. Values closer to 0 create more transparency, while values closer to 1 make the plot more opaque. (The same comment I made about setting the color of a filled in graph also applies here with alpha.)\n\nax = df[\"gpa\"].plot.density(label=\"Class A\")\nx = ax.lines[0].get_xdata()\ny = ax.lines[0].get_ydata()\nax.fill_between(x, y, color=\"blue\", alpha=0.5)\n\nmore_data.plot.density(label=\"Class B\")\n\nx2 = ax.lines[1].get_xdata()\ny2 = ax.lines[1].get_ydata()\nax.fill_between(x2, y2, color=\"red\", alpha=0.5)\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nOne of the most important parameters for density plots is bw_method, which accepts a float or string value. This parameter affects how smooth or detailed your curve appears. A smaller float (like 0.1) creates a more detailed, jagged curve that follows the data closely, while a larger float (like 0.5) creates a smoother, more generalized curve. The string options include 'scott' and 'silverman'.\nI will demonstrate by showing each of the methods.\n\ndf[\"gpa\"].plot.density(bw_method=0.1, label=\"Low Float\")\nplt.legend() \nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(bw_method=0.5, label=\"High Float\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(bw_method=\"scott\", label=\"Scott\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(bw_method=\"silverman\", label=\"Silverman\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nWe can control the style of the line using the linestyle parameter, which is the same as in previous graphs.\n\ndf[\"gpa\"].plot.density(linestyle=\"--\", color=\"green\")\nplt.show()\n\n\n\n\n\n\n\n\nThe linewidth parameter is the same as with previous graphs.\n\ndf[\"gpa\"].plot.density(linewidth=0.5, label=\"Thin Line\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(linewidth=3, label=\"Thick Line\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFor density plots, we can also specify the range of x-values we want to plot using xlim, which accepts a tuple of two float values (min, max). This parameter is particularly useful when comparing datasets with different ranges, as it allows you to focus on a specific portion of the distribution or standardize the viewing window across multiple plots.\nIt also has an equivalent function for y called ylim.\n\ndf[\"gpa\"].plot.density(xlim=(0, 4), color=\"blue\")\nplt.show()\n\n\n\n\n\n\n\n\n\ndf[\"gpa\"].plot.density(ylim=(0, 1), color=\"blue\")\nplt.show()\n\n\n\n\n\n\n\n\nFinally, let’s put everything together to create a comprehensive density plot with all the customizations we’ve learned:\n\ndf[\"gpa\"].plot.density(color=\"purple\", alpha=0.6, xlim=(0,4), ylim=(0,1), linewidth=3, linestyle=\"-\", label=\"Morning Class\")\nmore_data.plot.density(color=\"orange\", alpha=0.6, xlim=(0,4), ylim=(0,1), linewidth=3, linestyle=\"--\", label=\"Evening Class\")\n\nplt.xlabel(\"GPA\")\nplt.ylabel(\"Density\")\nplt.title(\"Student GPA Distribution Analysis\")\nplt.legend(loc=\"upper left\")\nplt.grid(True, alpha=0.3)\nplt.text(0.95, 0.95, \"Density shows probability distribution\", ha=\"right\", va=\"top\", transform=plt.gca().transAxes)\nplt.show()\n\n\n\n\n\n\n\n\nThis covers all the essential aspects of creating density plots in matplotlib. Density plots are particularly useful when you want to see the smooth distribution of your data and compare the shapes of multiple datasets without the discrete bins that histograms create."
  },
  {
    "objectID": "blog.html#conclusion",
    "href": "blog.html#conclusion",
    "title": "An Introduction to Visualizations in Python",
    "section": "Conclusion",
    "text": "Conclusion\nThroughout this tutorial, you’ve developed essential data visualization skills that will transform how you analyze and present information. You’ve learned the art of creating histograms, boxplots, and density plots.\nHowever, how do you know when to actually use these plots? It depends on the characteristics of your data and your analytical goals. If you are examining the shape and frequency distribution of your features, then use histograms. If you need to see what the cumulative count is in your datasets, use a stacked histogram. If you are interested in specific statistical view of your data, then you can use boxplots to view the the variability and outliers in your data. You can even compare how it differs across different groups of data. If you need a smooth looking representation of your graph’s shape, then consider using density plots, especially if you need to overlay multiple datasets on top of each other. Examining your data, your goals, and your available plots can help you find the best one for hte job.\nThis tutorial is intended to be a general introduction to some of matplotlib’s plots and the most important parameters in each. As I have said before, not all parameters are included. If you want more information on how matplotlib’s graphs, then I refer you to their plot page, which contains all their plots: Matplotlib_plots\nI encourage you to use the skills you learned here in making these plots to go and try to craft some of the other plots, such as a violin plot or a stem plot. I highly suggest that you open up your own python file and begin experimenting with, not just the graphs that I have given you, but all the graphs that matplotlib has to offer. Knowing what kind of plots there are and how to use them, will make it far easier when you need to select a plot in the future for your data. Additionally, coding up that plot, and coding it up to look nice, will be far easier if you have some practice and knowledge beforehand.\nIf you are even more interested in plotting and want to go further, then I recommend Seaborn. This is a library that is built on top of matplotlib that allows you further enhance the aesthetics of your visualizations. You can find the introduction to Seaborn here: Seaborn_introduction\nAdditionally, if you want to use some real datasets from off the internet, rather than simply creating your own data to work with, then I recommend using Zenodo. They offer thousands of open source datasets that you can download and use to further your visualization skills. You can find some datasets from them here: Zenodo_datasets\nNow, with these tools at hand, go forth, obtain or create a dataset of your own, and create graphs to better understand the data!\nRemember, a critical step in understanding data, is actually being able to see the data. Have fun visualizing!\n(Plans are in the works for a blog post are visualizing the relationship between features, so keep an eye out for that!)\n-Cassandra\nA special thanks to the people who developed matplotlib! Without them, this kind of easy visualization wouldn’t be possible.\n\n\n\nmatplotlib logo"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Data Science - Brigham Young University, Apr 2027\nRelevant Coursework: Data Structures, Computational Linear Algebra, Computer Systems, Discrete Structure, Statistical Modeling, Advanced Software Construction, Mathematics of Data Science, Algorithm Design & Analysis, Data Science Process, and Technical Communication."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About Me",
    "section": "",
    "text": "Data Science - Brigham Young University, Apr 2027\nRelevant Coursework: Data Structures, Computational Linear Algebra, Computer Systems, Discrete Structure, Statistical Modeling, Advanced Software Construction, Mathematics of Data Science, Algorithm Design & Analysis, Data Science Process, and Technical Communication."
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "About Me",
    "section": "Experience",
    "text": "Experience\n\nVegetable Preparation Chef for Brigham Young University Catering, Sep 2023 - Present\n\nCoordinated with a team of 8 to prepare appetizers and meals for various regular and high-end events\n\nComputer Science 111 Teaching Assistant for Brigham Young University Computer Science Department, Jan 2024 - Apr 2024\n\nCollaborated with a team of 6 to assist students in debugging code and understanding complex coding topics.\n\nBrigham Young University Connect Brand Ambassador Coordinator for Brigham Young University, Sep 2025 - Present\n\nCreated a team of Ambassadors for the purpose of promoting BYU Connect, thus improving overall number of mentorship relationships"
  },
  {
    "objectID": "about.html#skills",
    "href": "about.html#skills",
    "title": "About Me",
    "section": "Skills",
    "text": "Skills\n\nProgramming: Python, C++, C, Java\nData Analysis: Pandas, NumPy, SQL\nVisualization: Matplotlib, Seaborn\nMachine Learning: Scikit-learn\nTools: Jupyter Notebooks, Git/GitHub, AWS\n\n\nSoft Skills\n\nSelf Discipline\nCritical Thinking\nOrganized\nStrong Communicator\nTime Management\nTeamwork"
  },
  {
    "objectID": "about.html#get-to-know-me",
    "href": "about.html#get-to-know-me",
    "title": "About Me",
    "section": "Get to Know Me",
    "text": "Get to Know Me\n\nI’m currently a Junior at BYU studying data science\nI am pursuing a career as a data scientist or a data analyst\nHobbies: When I’m not programming I enjoy reading anything in the fiction genre or playing video games with my siblings\nFun Fact: I have never broken a bone\nInterests: I enjoy listening to stories people have to tell, from banal to interesting, and I hope to start a flower garden in the future (my favorite flowers are lilies)\n\n\n\n\nheadshot"
  },
  {
    "objectID": "about.html#contact",
    "href": "about.html#contact",
    "title": "About Me",
    "section": "Contact",
    "text": "Contact\n\nEmail: cnelson1845@gmail.com\nGitHub: github.com/CNelson2004\nLinkedIn: www.linkedin.com/in/cassandra-nelson1"
  },
  {
    "objectID": "blog2.html",
    "href": "blog2.html",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "Post in progress…\nPlease check again later for a completed post, the following is merely an outline.\n\n\nHello again. In my previous visualization post we discussed how to plot graphs when you are looking at exactly 1 feature, this time we will continue our learning by moving on to 2 features and further!\n\n\n\n\n\nBefore we begin, we need to download a dataset to work with. To do so, we will be using …\n\n\n\nNow we will find out exactly what data we are working with. By this, I mean that we will check exactly how the information is stored within our DataFrame.\n\n\n\n\nIn a previous post we’ve looked at visualizations that focus on one variable at a time. These are great for showing distributions, but often in data science, what we care about is the relationship between at least two variables.\nIn this section, we’ll cover how to use matplotlib to show relationships between pairs of features in our dataset.\nThe first type of plot we’ll cover is the scatter plot.\n\n\n\n\n\n\n\n\n\n\n\n\nFor this section, we will only cover how to use the scatterplot we are familiar with to move from a 2D into a 3D setting."
  },
  {
    "objectID": "blog2.html#introduction",
    "href": "blog2.html#introduction",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "Hello again. In my previous visualization post we discussed how to plot graphs when you are looking at exactly 1 feature, this time we will continue our learning by moving on to 2 features and further!"
  },
  {
    "objectID": "blog2.html#pandas",
    "href": "blog2.html#pandas",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "Before we begin, we need to download a dataset to work with. To do so, we will be using …\n\n\n\nNow we will find out exactly what data we are working with. By this, I mean that we will check exactly how the information is stored within our DataFrame."
  },
  {
    "objectID": "blog2.html#relationship-graphs-2-features",
    "href": "blog2.html#relationship-graphs-2-features",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "In a previous post we’ve looked at visualizations that focus on one variable at a time. These are great for showing distributions, but often in data science, what we care about is the relationship between at least two variables.\nIn this section, we’ll cover how to use matplotlib to show relationships between pairs of features in our dataset.\nThe first type of plot we’ll cover is the scatter plot."
  },
  {
    "objectID": "blog2.html#d-graphs",
    "href": "blog2.html#d-graphs",
    "title": "An Introduction to Visualizations in Python-Part 2",
    "section": "",
    "text": "For this section, we will only cover how to use the scatterplot we are familiar with to move from a 2D into a 3D setting."
  }
]